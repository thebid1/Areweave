"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgCalibrateDelegationResponse = exports.MsgCalibrateDelegation = exports.MsgUndelegateHostResponse = exports.MsgUndelegateHost = exports.MsgUpdateValidatorSharesExchRateResponse = exports.MsgUpdateValidatorSharesExchRate = exports.MsgRestoreInterchainAccountResponse = exports.MsgRestoreInterchainAccount = exports.MsgDeleteValidatorResponse = exports.MsgDeleteValidator = exports.MsgChangeValidatorWeightResponse = exports.MsgChangeValidatorWeight = exports.MsgAddValidatorsResponse = exports.MsgAddValidators = exports.MsgRebalanceValidatorsResponse = exports.MsgRebalanceValidators = exports.MsgClaimUndelegatedTokensResponse = exports.MsgClaimUndelegatedTokens = exports.MsgRegisterHostZoneResponse = exports.MsgRegisterHostZone = exports.MsgRedeemStakeResponse = exports.MsgRedeemStake = exports.MsgClearBalanceResponse = exports.MsgClearBalance = exports.MsgLSMLiquidStakeResponse = exports.MsgLSMLiquidStake = exports.MsgLiquidStakeResponse = exports.MsgLiquidStake = exports.MsgUpdateInnerRedemptionRateBoundsResponse = exports.MsgUpdateInnerRedemptionRateBounds = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const ica_account_1 = require("../../stride/stakeibc/ica_account");
const validator_1 = require("../../stride/stakeibc/validator");
exports.protobufPackage = "stride.stakeibc";
function createBaseMsgUpdateInnerRedemptionRateBounds() {
    return {
        creator: "",
        chainId: "",
        minInnerRedemptionRate: "",
        maxInnerRedemptionRate: "",
    };
}
exports.MsgUpdateInnerRedemptionRateBounds = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.minInnerRedemptionRate !== "") {
            writer.uint32(26).string(message.minInnerRedemptionRate);
        }
        if (message.maxInnerRedemptionRate !== "") {
            writer.uint32(34).string(message.maxInnerRedemptionRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.minInnerRedemptionRate = reader.string();
                    break;
                case 4:
                    message.maxInnerRedemptionRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            chainId: isSet(object.chainId) ? String(object.chainId) : "",
            minInnerRedemptionRate: isSet(object.minInnerRedemptionRate)
                ? String(object.minInnerRedemptionRate)
                : "",
            maxInnerRedemptionRate: isSet(object.maxInnerRedemptionRate)
                ? String(object.maxInnerRedemptionRate)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.minInnerRedemptionRate !== undefined &&
            (obj.minInnerRedemptionRate = message.minInnerRedemptionRate);
        message.maxInnerRedemptionRate !== undefined &&
            (obj.maxInnerRedemptionRate = message.maxInnerRedemptionRate);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.minInnerRedemptionRate = (_c = object.minInnerRedemptionRate) !== null && _c !== void 0 ? _c : "";
        message.maxInnerRedemptionRate = (_d = object.maxInnerRedemptionRate) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseMsgUpdateInnerRedemptionRateBoundsResponse() {
    return {};
}
exports.MsgUpdateInnerRedemptionRateBoundsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        return message;
    },
};
function createBaseMsgLiquidStake() {
    return { creator: "", amount: "", hostDenom: "" };
}
exports.MsgLiquidStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.hostDenom !== "") {
            writer.uint32(26).string(message.hostDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStake();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.hostDenom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            hostDenom: isSet(object.hostDenom) ? String(object.hostDenom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.amount !== undefined && (obj.amount = message.amount);
        message.hostDenom !== undefined && (obj.hostDenom = message.hostDenom);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgLiquidStake();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.hostDenom = (_c = object.hostDenom) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgLiquidStakeResponse() {
    return {};
}
exports.MsgLiquidStakeResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStakeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgLiquidStakeResponse();
        return message;
    },
};
function createBaseMsgLSMLiquidStake() {
    return { creator: "", amount: "", lsmTokenIbcDenom: "" };
}
exports.MsgLSMLiquidStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.lsmTokenIbcDenom !== "") {
            writer.uint32(26).string(message.lsmTokenIbcDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLSMLiquidStake();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.lsmTokenIbcDenom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            lsmTokenIbcDenom: isSet(object.lsmTokenIbcDenom)
                ? String(object.lsmTokenIbcDenom)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.amount !== undefined && (obj.amount = message.amount);
        message.lsmTokenIbcDenom !== undefined &&
            (obj.lsmTokenIbcDenom = message.lsmTokenIbcDenom);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgLSMLiquidStake();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.lsmTokenIbcDenom = (_c = object.lsmTokenIbcDenom) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgLSMLiquidStakeResponse() {
    return { transactionComplete: false };
}
exports.MsgLSMLiquidStakeResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.transactionComplete === true) {
            writer.uint32(8).bool(message.transactionComplete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLSMLiquidStakeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transactionComplete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            transactionComplete: isSet(object.transactionComplete)
                ? Boolean(object.transactionComplete)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.transactionComplete !== undefined &&
            (obj.transactionComplete = message.transactionComplete);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgLSMLiquidStakeResponse();
        message.transactionComplete = (_a = object.transactionComplete) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
function createBaseMsgClearBalance() {
    return { creator: "", chainId: "", amount: "", channel: "" };
}
exports.MsgClearBalance = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.amount !== "") {
            writer.uint32(26).string(message.amount);
        }
        if (message.channel !== "") {
            writer.uint32(34).string(message.channel);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClearBalance();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.amount = reader.string();
                    break;
                case 4:
                    message.channel = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            chainId: isSet(object.chainId) ? String(object.chainId) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            channel: isSet(object.channel) ? String(object.channel) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.amount !== undefined && (obj.amount = message.amount);
        message.channel !== undefined && (obj.channel = message.channel);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgClearBalance();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.amount = (_c = object.amount) !== null && _c !== void 0 ? _c : "";
        message.channel = (_d = object.channel) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseMsgClearBalanceResponse() {
    return {};
}
exports.MsgClearBalanceResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClearBalanceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgClearBalanceResponse();
        return message;
    },
};
function createBaseMsgRedeemStake() {
    return { creator: "", amount: "", hostZone: "", receiver: "" };
}
exports.MsgRedeemStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.hostZone !== "") {
            writer.uint32(26).string(message.hostZone);
        }
        if (message.receiver !== "") {
            writer.uint32(34).string(message.receiver);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStake();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.hostZone = reader.string();
                    break;
                case 4:
                    message.receiver = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            hostZone: isSet(object.hostZone) ? String(object.hostZone) : "",
            receiver: isSet(object.receiver) ? String(object.receiver) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.amount !== undefined && (obj.amount = message.amount);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.receiver !== undefined && (obj.receiver = message.receiver);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgRedeemStake();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.hostZone = (_c = object.hostZone) !== null && _c !== void 0 ? _c : "";
        message.receiver = (_d = object.receiver) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseMsgRedeemStakeResponse() {
    return {};
}
exports.MsgRedeemStakeResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStakeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgRedeemStakeResponse();
        return message;
    },
};
function createBaseMsgRegisterHostZone() {
    return {
        connectionId: "",
        bech32prefix: "",
        hostDenom: "",
        ibcDenom: "",
        creator: "",
        transferChannelId: "",
        unbondingPeriod: "0",
        minRedemptionRate: "",
        maxRedemptionRate: "",
        lsmLiquidStakeEnabled: false,
    };
}
exports.MsgRegisterHostZone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
            writer.uint32(18).string(message.connectionId);
        }
        if (message.bech32prefix !== "") {
            writer.uint32(98).string(message.bech32prefix);
        }
        if (message.hostDenom !== "") {
            writer.uint32(34).string(message.hostDenom);
        }
        if (message.ibcDenom !== "") {
            writer.uint32(42).string(message.ibcDenom);
        }
        if (message.creator !== "") {
            writer.uint32(50).string(message.creator);
        }
        if (message.transferChannelId !== "") {
            writer.uint32(82).string(message.transferChannelId);
        }
        if (message.unbondingPeriod !== "0") {
            writer.uint32(88).uint64(message.unbondingPeriod);
        }
        if (message.minRedemptionRate !== "") {
            writer.uint32(106).string(message.minRedemptionRate);
        }
        if (message.maxRedemptionRate !== "") {
            writer.uint32(114).string(message.maxRedemptionRate);
        }
        if (message.lsmLiquidStakeEnabled === true) {
            writer.uint32(120).bool(message.lsmLiquidStakeEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterHostZone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.connectionId = reader.string();
                    break;
                case 12:
                    message.bech32prefix = reader.string();
                    break;
                case 4:
                    message.hostDenom = reader.string();
                    break;
                case 5:
                    message.ibcDenom = reader.string();
                    break;
                case 6:
                    message.creator = reader.string();
                    break;
                case 10:
                    message.transferChannelId = reader.string();
                    break;
                case 11:
                    message.unbondingPeriod = longToString(reader.uint64());
                    break;
                case 13:
                    message.minRedemptionRate = reader.string();
                    break;
                case 14:
                    message.maxRedemptionRate = reader.string();
                    break;
                case 15:
                    message.lsmLiquidStakeEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            connectionId: isSet(object.connectionId)
                ? String(object.connectionId)
                : "",
            bech32prefix: isSet(object.bech32prefix)
                ? String(object.bech32prefix)
                : "",
            hostDenom: isSet(object.hostDenom) ? String(object.hostDenom) : "",
            ibcDenom: isSet(object.ibcDenom) ? String(object.ibcDenom) : "",
            creator: isSet(object.creator) ? String(object.creator) : "",
            transferChannelId: isSet(object.transferChannelId)
                ? String(object.transferChannelId)
                : "",
            unbondingPeriod: isSet(object.unbondingPeriod)
                ? String(object.unbondingPeriod)
                : "0",
            minRedemptionRate: isSet(object.minRedemptionRate)
                ? String(object.minRedemptionRate)
                : "",
            maxRedemptionRate: isSet(object.maxRedemptionRate)
                ? String(object.maxRedemptionRate)
                : "",
            lsmLiquidStakeEnabled: isSet(object.lsmLiquidStakeEnabled)
                ? Boolean(object.lsmLiquidStakeEnabled)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.connectionId !== undefined &&
            (obj.connectionId = message.connectionId);
        message.bech32prefix !== undefined &&
            (obj.bech32prefix = message.bech32prefix);
        message.hostDenom !== undefined && (obj.hostDenom = message.hostDenom);
        message.ibcDenom !== undefined && (obj.ibcDenom = message.ibcDenom);
        message.creator !== undefined && (obj.creator = message.creator);
        message.transferChannelId !== undefined &&
            (obj.transferChannelId = message.transferChannelId);
        message.unbondingPeriod !== undefined &&
            (obj.unbondingPeriod = message.unbondingPeriod);
        message.minRedemptionRate !== undefined &&
            (obj.minRedemptionRate = message.minRedemptionRate);
        message.maxRedemptionRate !== undefined &&
            (obj.maxRedemptionRate = message.maxRedemptionRate);
        message.lsmLiquidStakeEnabled !== undefined &&
            (obj.lsmLiquidStakeEnabled = message.lsmLiquidStakeEnabled);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseMsgRegisterHostZone();
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        message.bech32prefix = (_b = object.bech32prefix) !== null && _b !== void 0 ? _b : "";
        message.hostDenom = (_c = object.hostDenom) !== null && _c !== void 0 ? _c : "";
        message.ibcDenom = (_d = object.ibcDenom) !== null && _d !== void 0 ? _d : "";
        message.creator = (_e = object.creator) !== null && _e !== void 0 ? _e : "";
        message.transferChannelId = (_f = object.transferChannelId) !== null && _f !== void 0 ? _f : "";
        message.unbondingPeriod = (_g = object.unbondingPeriod) !== null && _g !== void 0 ? _g : "0";
        message.minRedemptionRate = (_h = object.minRedemptionRate) !== null && _h !== void 0 ? _h : "";
        message.maxRedemptionRate = (_j = object.maxRedemptionRate) !== null && _j !== void 0 ? _j : "";
        message.lsmLiquidStakeEnabled = (_k = object.lsmLiquidStakeEnabled) !== null && _k !== void 0 ? _k : false;
        return message;
    },
};
function createBaseMsgRegisterHostZoneResponse() {
    return {};
}
exports.MsgRegisterHostZoneResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterHostZoneResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgRegisterHostZoneResponse();
        return message;
    },
};
function createBaseMsgClaimUndelegatedTokens() {
    return { creator: "", hostZoneId: "", epoch: "0", sender: "" };
}
exports.MsgClaimUndelegatedTokens = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZoneId !== "") {
            writer.uint32(18).string(message.hostZoneId);
        }
        if (message.epoch !== "0") {
            writer.uint32(24).uint64(message.epoch);
        }
        if (message.sender !== "") {
            writer.uint32(34).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClaimUndelegatedTokens();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZoneId = reader.string();
                    break;
                case 3:
                    message.epoch = longToString(reader.uint64());
                    break;
                case 4:
                    message.sender = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            hostZoneId: isSet(object.hostZoneId) ? String(object.hostZoneId) : "",
            epoch: isSet(object.epoch) ? String(object.epoch) : "0",
            sender: isSet(object.sender) ? String(object.sender) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        message.epoch !== undefined && (obj.epoch = message.epoch);
        message.sender !== undefined && (obj.sender = message.sender);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgClaimUndelegatedTokens();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.hostZoneId = (_b = object.hostZoneId) !== null && _b !== void 0 ? _b : "";
        message.epoch = (_c = object.epoch) !== null && _c !== void 0 ? _c : "0";
        message.sender = (_d = object.sender) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseMsgClaimUndelegatedTokensResponse() {
    return {};
}
exports.MsgClaimUndelegatedTokensResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClaimUndelegatedTokensResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgClaimUndelegatedTokensResponse();
        return message;
    },
};
function createBaseMsgRebalanceValidators() {
    return { creator: "", hostZone: "", numRebalance: "0" };
}
exports.MsgRebalanceValidators = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
            writer.uint32(18).string(message.hostZone);
        }
        if (message.numRebalance !== "0") {
            writer.uint32(24).uint64(message.numRebalance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRebalanceValidators();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZone = reader.string();
                    break;
                case 3:
                    message.numRebalance = longToString(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            hostZone: isSet(object.hostZone) ? String(object.hostZone) : "",
            numRebalance: isSet(object.numRebalance)
                ? String(object.numRebalance)
                : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.numRebalance !== undefined &&
            (obj.numRebalance = message.numRebalance);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgRebalanceValidators();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.hostZone = (_b = object.hostZone) !== null && _b !== void 0 ? _b : "";
        message.numRebalance = (_c = object.numRebalance) !== null && _c !== void 0 ? _c : "0";
        return message;
    },
};
function createBaseMsgRebalanceValidatorsResponse() {
    return {};
}
exports.MsgRebalanceValidatorsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRebalanceValidatorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgRebalanceValidatorsResponse();
        return message;
    },
};
function createBaseMsgAddValidators() {
    return { creator: "", hostZone: "", validators: [] };
}
exports.MsgAddValidators = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
            writer.uint32(18).string(message.hostZone);
        }
        for (const v of message.validators) {
            validator_1.Validator.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddValidators();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZone = reader.string();
                    break;
                case 3:
                    message.validators.push(validator_1.Validator.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            hostZone: isSet(object.hostZone) ? String(object.hostZone) : "",
            validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators)
                ? object.validators.map((e) => validator_1.Validator.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        if (message.validators) {
            obj.validators = message.validators.map((e) => e ? validator_1.Validator.toJSON(e) : undefined);
        }
        else {
            obj.validators = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgAddValidators();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.hostZone = (_b = object.hostZone) !== null && _b !== void 0 ? _b : "";
        message.validators =
            ((_c = object.validators) === null || _c === void 0 ? void 0 : _c.map((e) => validator_1.Validator.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMsgAddValidatorsResponse() {
    return {};
}
exports.MsgAddValidatorsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddValidatorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgAddValidatorsResponse();
        return message;
    },
};
function createBaseMsgChangeValidatorWeight() {
    return { creator: "", hostZone: "", valAddr: "", weight: "0" };
}
exports.MsgChangeValidatorWeight = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
            writer.uint32(18).string(message.hostZone);
        }
        if (message.valAddr !== "") {
            writer.uint32(26).string(message.valAddr);
        }
        if (message.weight !== "0") {
            writer.uint32(32).uint64(message.weight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChangeValidatorWeight();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZone = reader.string();
                    break;
                case 3:
                    message.valAddr = reader.string();
                    break;
                case 4:
                    message.weight = longToString(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            hostZone: isSet(object.hostZone) ? String(object.hostZone) : "",
            valAddr: isSet(object.valAddr) ? String(object.valAddr) : "",
            weight: isSet(object.weight) ? String(object.weight) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.valAddr !== undefined && (obj.valAddr = message.valAddr);
        message.weight !== undefined && (obj.weight = message.weight);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgChangeValidatorWeight();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.hostZone = (_b = object.hostZone) !== null && _b !== void 0 ? _b : "";
        message.valAddr = (_c = object.valAddr) !== null && _c !== void 0 ? _c : "";
        message.weight = (_d = object.weight) !== null && _d !== void 0 ? _d : "0";
        return message;
    },
};
function createBaseMsgChangeValidatorWeightResponse() {
    return {};
}
exports.MsgChangeValidatorWeightResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChangeValidatorWeightResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgChangeValidatorWeightResponse();
        return message;
    },
};
function createBaseMsgDeleteValidator() {
    return { creator: "", hostZone: "", valAddr: "" };
}
exports.MsgDeleteValidator = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
            writer.uint32(18).string(message.hostZone);
        }
        if (message.valAddr !== "") {
            writer.uint32(26).string(message.valAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeleteValidator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZone = reader.string();
                    break;
                case 3:
                    message.valAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            hostZone: isSet(object.hostZone) ? String(object.hostZone) : "",
            valAddr: isSet(object.valAddr) ? String(object.valAddr) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.valAddr !== undefined && (obj.valAddr = message.valAddr);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgDeleteValidator();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.hostZone = (_b = object.hostZone) !== null && _b !== void 0 ? _b : "";
        message.valAddr = (_c = object.valAddr) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgDeleteValidatorResponse() {
    return {};
}
exports.MsgDeleteValidatorResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeleteValidatorResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgDeleteValidatorResponse();
        return message;
    },
};
function createBaseMsgRestoreInterchainAccount() {
    return { creator: "", chainId: "", accountType: 0 };
}
exports.MsgRestoreInterchainAccount = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.accountType !== 0) {
            writer.uint32(24).int32(message.accountType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRestoreInterchainAccount();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.accountType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            chainId: isSet(object.chainId) ? String(object.chainId) : "",
            accountType: isSet(object.accountType)
                ? (0, ica_account_1.iCAAccountTypeFromJSON)(object.accountType)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.accountType !== undefined &&
            (obj.accountType = (0, ica_account_1.iCAAccountTypeToJSON)(message.accountType));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgRestoreInterchainAccount();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.accountType = (_c = object.accountType) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseMsgRestoreInterchainAccountResponse() {
    return {};
}
exports.MsgRestoreInterchainAccountResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRestoreInterchainAccountResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgRestoreInterchainAccountResponse();
        return message;
    },
};
function createBaseMsgUpdateValidatorSharesExchRate() {
    return { creator: "", chainId: "", valoper: "" };
}
exports.MsgUpdateValidatorSharesExchRate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.valoper !== "") {
            writer.uint32(26).string(message.valoper);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateValidatorSharesExchRate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.valoper = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            chainId: isSet(object.chainId) ? String(object.chainId) : "",
            valoper: isSet(object.valoper) ? String(object.valoper) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.valoper !== undefined && (obj.valoper = message.valoper);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgUpdateValidatorSharesExchRate();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.valoper = (_c = object.valoper) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgUpdateValidatorSharesExchRateResponse() {
    return {};
}
exports.MsgUpdateValidatorSharesExchRateResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateValidatorSharesExchRateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateValidatorSharesExchRateResponse();
        return message;
    },
};
function createBaseMsgUndelegateHost() {
    return { creator: "", amount: "" };
}
exports.MsgUndelegateHost = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateHost();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgUndelegateHost();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgUndelegateHostResponse() {
    return {};
}
exports.MsgUndelegateHostResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateHostResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgUndelegateHostResponse();
        return message;
    },
};
function createBaseMsgCalibrateDelegation() {
    return { creator: "", chainId: "", valoper: "" };
}
exports.MsgCalibrateDelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.valoper !== "") {
            writer.uint32(26).string(message.valoper);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCalibrateDelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.valoper = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            chainId: isSet(object.chainId) ? String(object.chainId) : "",
            valoper: isSet(object.valoper) ? String(object.valoper) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.valoper !== undefined && (obj.valoper = message.valoper);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgCalibrateDelegation();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.valoper = (_c = object.valoper) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgCalibrateDelegationResponse() {
    return {};
}
exports.MsgCalibrateDelegationResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCalibrateDelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgCalibrateDelegationResponse();
        return message;
    },
};
function longToString(long) {
    return long.toString();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=tx.js.map