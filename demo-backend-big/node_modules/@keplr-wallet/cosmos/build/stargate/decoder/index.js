"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtoSignDocDecoder = void 0;
const tx_1 = require("@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx");
const codec_1 = require("../codec");
const signing_1 = require("@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing");
const common_1 = require("@keplr-wallet/common");
class ProtoSignDocDecoder {
    static decode(bytes) {
        return new ProtoSignDocDecoder(tx_1.SignDoc.decode(bytes));
    }
    constructor(signDoc, protoCodec = codec_1.defaultProtoCodec) {
        this.signDoc = signDoc;
        this.protoCodec = protoCodec;
    }
    get txBody() {
        if (!this._txBody) {
            this._txBody = tx_1.TxBody.decode(this.signDoc.bodyBytes);
        }
        return this._txBody;
    }
    get txMsgs() {
        const msgs = [];
        for (const msg of this.txBody.messages) {
            msgs.push(this.protoCodec.unpackAny(msg));
        }
        return msgs;
    }
    get authInfo() {
        if (!this._authInfo) {
            if ("authInfoBytes" in this.signDoc) {
                this._authInfo = tx_1.AuthInfo.decode(this.signDoc.authInfoBytes);
            }
            else {
                // 사실 direct aux에서 auth info를 만들어내는 것은 불가능하다.
                // 하지만 기존 코드를 재활용하기 위해서 필요하니 일단 적당히 만들어준다.
                const directAux = this.signDoc;
                this._authInfo = tx_1.AuthInfo.fromPartial({
                    signerInfos: [
                        {
                            publicKey: directAux.publicKey,
                            modeInfo: {
                                single: {
                                    mode: signing_1.SignMode.SIGN_MODE_DIRECT,
                                },
                            },
                            sequence: directAux.sequence,
                        },
                    ],
                    fee: {
                        amount: [],
                        gasLimit: "1",
                        payer: "",
                        granter: "",
                    },
                });
            }
        }
        return this._authInfo;
    }
    get chainId() {
        return this.signDoc.chainId;
    }
    get accountNumber() {
        return this.signDoc.accountNumber.toString();
    }
    toBytes() {
        if ("authInfoBytes" in this.signDoc) {
            return tx_1.SignDoc.encode(this.signDoc).finish();
        }
        return tx_1.SignDocDirectAux.encode(this.signDoc).finish();
    }
    toJSON() {
        if ("authInfoBytes" in this.signDoc) {
            return (0, common_1.sortObjectByKey)({
                txBody: Object.assign(Object.assign({}, tx_1.TxBody.toJSON(this.txBody)), {
                    messages: this.txMsgs.map((msg) => {
                        return this.protoCodec.unpackedAnyToJSONRecursive(msg);
                    }),
                }),
                authInfo: tx_1.AuthInfo.toJSON(this.authInfo),
                chainId: this.chainId,
                accountNumber: this.accountNumber,
            });
        }
        const directAuxJSON = tx_1.SignDocDirectAux.toJSON(this.signDoc);
        // bodyBytes는 어차피 json으로 보여줘도 못 알아먹는다.
        // 더 밑에서 txBody를 보여주기 때문에 bodyBytes는 삭제한다.
        if (directAuxJSON.bodyBytes) {
            delete directAuxJSON.bodyBytes;
        }
        return (0, common_1.sortObjectByKey)(Object.assign(Object.assign({}, directAuxJSON), { txBody: Object.assign(Object.assign({}, tx_1.TxBody.toJSON(this.txBody)), {
                messages: this.txMsgs.map((msg) => {
                    return this.protoCodec.unpackedAnyToJSONRecursive(msg);
                }),
            }) }));
    }
}
exports.ProtoSignDocDecoder = ProtoSignDocDecoder;
//# sourceMappingURL=index.js.map