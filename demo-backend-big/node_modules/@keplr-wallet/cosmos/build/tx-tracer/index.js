"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TendermintTxTracer = exports.WsReadyState = void 0;
const buffer_1 = require("buffer/");
var WsReadyState;
(function (WsReadyState) {
    WsReadyState[WsReadyState["CONNECTING"] = 0] = "CONNECTING";
    WsReadyState[WsReadyState["OPEN"] = 1] = "OPEN";
    WsReadyState[WsReadyState["CLOSING"] = 2] = "CLOSING";
    WsReadyState[WsReadyState["CLOSED"] = 3] = "CLOSED";
    // WS is not initialized or the ready state of WS is unknown
    WsReadyState[WsReadyState["NONE"] = 4] = "NONE";
})(WsReadyState = exports.WsReadyState || (exports.WsReadyState = {}));
class TendermintTxTracer {
    constructor(url, wsEndpoint, options = {}) {
        this.url = url;
        this.wsEndpoint = wsEndpoint;
        this.options = options;
        this.newBlockSubscribes = [];
        // Key is "id" for jsonrpc
        this.txSubscribes = new Map();
        // Key is "id" for jsonrpc
        this.pendingQueries = new Map();
        this.listeners = {};
        this.onOpen = (e) => {
            var _a;
            if (this.newBlockSubscribes.length > 0) {
                this.sendSubscribeBlockRpc();
            }
            for (const [id, tx] of this.txSubscribes) {
                this.sendSubscribeTxRpc(id, tx.params);
            }
            for (const [id, query] of this.pendingQueries) {
                this.sendQueryRpc(id, query.method, query.params);
            }
            for (const listener of (_a = this.listeners.open) !== null && _a !== void 0 ? _a : []) {
                listener(e);
            }
        };
        this.onMessage = (e) => {
            var _a, _b, _c, _d, _e, _f;
            for (const listener of (_a = this.listeners.message) !== null && _a !== void 0 ? _a : []) {
                listener(e);
            }
            if (e.data) {
                try {
                    const obj = JSON.parse(e.data);
                    if (obj === null || obj === void 0 ? void 0 : obj.id) {
                        if (this.pendingQueries.has(obj.id)) {
                            if (obj.error) {
                                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                this.pendingQueries
                                    .get(obj.id)
                                    .rejector(new Error(obj.error.data || obj.error.message));
                            }
                            else {
                                // XXX: I'm not sure why this happens, but somtimes the form of tx id delivered under the "tx_result" field.
                                if ((_b = obj.result) === null || _b === void 0 ? void 0 : _b.tx_result) {
                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                    this.pendingQueries.get(obj.id).resolver(obj.result.tx_result);
                                }
                                else {
                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                    this.pendingQueries.get(obj.id).resolver(obj.result);
                                }
                            }
                            this.pendingQueries.delete(obj.id);
                        }
                    }
                    if (((_d = (_c = obj === null || obj === void 0 ? void 0 : obj.result) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.type) === "tendermint/event/NewBlock") {
                        for (const handler of this.newBlockSubscribes) {
                            handler.handler(obj.result.data.value);
                        }
                    }
                    if (((_f = (_e = obj === null || obj === void 0 ? void 0 : obj.result) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.type) === "tendermint/event/Tx") {
                        if (obj === null || obj === void 0 ? void 0 : obj.id) {
                            if (this.txSubscribes.has(obj.id)) {
                                if (obj.error) {
                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                    this.txSubscribes
                                        .get(obj.id)
                                        .rejector(new Error(obj.error.data || obj.error.message));
                                }
                                else {
                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                    this.txSubscribes
                                        .get(obj.id)
                                        .resolver(obj.result.data.value.TxResult.result);
                                }
                                this.txSubscribes.delete(obj.id);
                            }
                        }
                    }
                }
                catch (e) {
                    console.log(`Tendermint websocket jsonrpc response is not JSON: ${e.message || e.toString()}`);
                }
            }
        };
        this.onClose = (e) => {
            var _a;
            for (const listener of (_a = this.listeners.close) !== null && _a !== void 0 ? _a : []) {
                listener(e);
            }
        };
        this.onError = (e) => {
            var _a;
            for (const listener of (_a = this.listeners.error) !== null && _a !== void 0 ? _a : []) {
                listener(e);
            }
            this.close();
        };
        this.ws = this.options.wsObject
            ? new this.options.wsObject(this.getWsEndpoint())
            : new WebSocket(this.getWsEndpoint());
        this.ws.onopen = this.onOpen;
        this.ws.onmessage = this.onMessage;
        this.ws.onclose = this.onClose;
        this.ws.onerror = this.onError;
    }
    getWsEndpoint() {
        let url = this.url;
        if (url.startsWith("http")) {
            url = url.replace("http", "ws");
        }
        if (!url.endsWith(this.wsEndpoint)) {
            const wsEndpoint = this.wsEndpoint.startsWith("/")
                ? this.wsEndpoint
                : "/" + this.wsEndpoint;
            url = url.endsWith("/") ? url + wsEndpoint.slice(1) : url + wsEndpoint;
        }
        return url;
    }
    close() {
        this.ws.close();
    }
    get readyState() {
        switch (this.ws.readyState) {
            case 0:
                return WsReadyState.CONNECTING;
            case 1:
                return WsReadyState.OPEN;
            case 2:
                return WsReadyState.CLOSING;
            case 3:
                return WsReadyState.CLOSED;
            default:
                return WsReadyState.NONE;
        }
    }
    addEventListener(type, listener) {
        if (!this.listeners[type]) {
            this.listeners[type] = [];
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.listeners[type].push(listener);
    }
    /**
     * SubscribeBlock receives the handler for the block.
     * The handelrs shares the subscription of block.
     * @param handler
     * @return unsubscriber
     */
    subscribeBlock(handler) {
        this.newBlockSubscribes.push({
            handler,
        });
        if (this.newBlockSubscribes.length === 1) {
            this.sendSubscribeBlockRpc();
        }
        return () => {
            this.newBlockSubscribes = this.newBlockSubscribes.filter((s) => s.handler !== handler);
        };
    }
    sendSubscribeBlockRpc() {
        if (this.readyState === WsReadyState.OPEN) {
            this.ws.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "subscribe",
                params: ["tm.event='NewBlock'"],
                id: 1,
            }));
        }
    }
    // Query the tx and subscribe the tx.
    traceTx(query) {
        let resolved = false;
        return new Promise((resolve) => {
            // At first, try to query the tx at the same time of subscribing the tx.
            // But, the querying's error will be ignored.
            this.queryTx(query)
                .then((result) => {
                if (query instanceof Uint8Array) {
                    resolve(result);
                    return;
                }
                if ((result === null || result === void 0 ? void 0 : result.total_count) !== "0") {
                    resolve(result);
                    return;
                }
            })
                .catch(() => {
                // noop
            });
            (() => __awaiter(this, void 0, void 0, function* () {
                // We don't know why yet. For some unknown reason, there is a problem where Tendermint does not give value through subscribe forever.
                // For now, as a simple solution, send tx_search periodically as well.
                while (true) {
                    if (resolved ||
                        this.readyState === WsReadyState.CLOSED ||
                        this.readyState === WsReadyState.CLOSING) {
                        break;
                    }
                    yield new Promise((resolve) => setTimeout(resolve, 10000));
                    this.queryTx(query)
                        .then((result) => {
                        if (query instanceof Uint8Array) {
                            resolve(result);
                            return;
                        }
                        if ((result === null || result === void 0 ? void 0 : result.total_count) !== "0") {
                            resolve(result);
                            return;
                        }
                    })
                        .catch(() => {
                        // noop
                    });
                }
            }))();
            this.subscribeTx(query).then(resolve);
        }).then((tx) => {
            resolved = true;
            // Occasionally, even if the subscribe tx event occurs, the state through query is not changed yet.
            // Perhaps it is because the block has not been committed yet even though the result of deliverTx in tendermint is complete.
            // This method is usually used to reflect the state change through query when tx is completed.
            // The simplest solution is to just add a little delay.
            return new Promise((resolve) => {
                setTimeout(() => resolve(tx), 100);
            });
        });
    }
    subscribeTx(query) {
        if (query instanceof Uint8Array) {
            const id = this.createRandomId();
            const params = {
                query: `tm.event='Tx' AND tx.hash='${buffer_1.Buffer.from(query)
                    .toString("hex")
                    .toUpperCase()}'`,
            };
            return new Promise((resolve, reject) => {
                this.txSubscribes.set(id, {
                    params,
                    resolver: resolve,
                    rejector: reject,
                });
                this.sendSubscribeTxRpc(id, params);
            });
        }
        else {
            const id = this.createRandomId();
            const params = {
                query: `tm.event='Tx' AND ` +
                    Object.keys(query)
                        .map((key) => {
                        return {
                            key,
                            value: query[key],
                        };
                    })
                        .map((obj) => {
                        return `${obj.key}=${typeof obj.value === "string" ? `'${obj.value}'` : obj.value}`;
                    })
                        .join(" AND "),
                page: "1",
                per_page: "1",
                order_by: "asc",
            };
            return new Promise((resolve, reject) => {
                this.txSubscribes.set(id, {
                    params,
                    resolver: resolve,
                    rejector: reject,
                });
                this.sendSubscribeTxRpc(id, params);
            });
        }
    }
    sendSubscribeTxRpc(id, params) {
        if (this.readyState === WsReadyState.OPEN) {
            this.ws.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "subscribe",
                params: params,
                id,
            }));
        }
    }
    queryTx(query) {
        if (query instanceof Uint8Array) {
            return this.query("tx", {
                hash: buffer_1.Buffer.from(query).toString("base64"),
                prove: false,
            });
        }
        else {
            const params = {
                query: Object.keys(query)
                    .map((key) => {
                    return {
                        key,
                        value: query[key],
                    };
                })
                    .map((obj) => {
                    return `${obj.key}=${typeof obj.value === "string" ? `'${obj.value}'` : obj.value}`;
                })
                    .join(" AND "),
                page: "1",
                per_page: "1",
                order_by: "asc",
            };
            return this.query("tx_search", params);
        }
    }
    query(method, params) {
        const id = this.createRandomId();
        return new Promise((resolve, reject) => {
            this.pendingQueries.set(id, {
                method,
                params,
                resolver: resolve,
                rejector: reject,
            });
            this.sendQueryRpc(id, method, params);
        });
    }
    sendQueryRpc(id, method, params) {
        if (this.readyState === WsReadyState.OPEN) {
            this.ws.send(JSON.stringify({
                jsonrpc: "2.0",
                method,
                params,
                id,
            }));
        }
    }
    createRandomId() {
        return parseInt(Array.from({ length: 6 })
            .map(() => Math.floor(Math.random() * 100))
            .join(""));
    }
}
exports.TendermintTxTracer = TendermintTxTracer;
//# sourceMappingURL=index.js.map