/**
 * Copyright (C) 2022-2024 Permanent Data Solutions, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { BigNumber } from 'bignumber.js';
import { Buffer } from 'node:buffer';
import { TurboHTTPService } from './http.js';
import { TurboWinstonLogger } from './logger.js';
import { exponentMap, tokenToBaseMap } from './token/index.js';
export const developmentPaymentServiceURL = 'https://payment.ardrive.dev';
export const defaultPaymentServiceURL = 'https://payment.ardrive.io';
export class TurboUnauthenticatedPaymentService {
    constructor({ url = defaultPaymentServiceURL, retryConfig, logger = TurboWinstonLogger.default, token = 'arweave', }) {
        this.logger = logger;
        this.httpService = new TurboHTTPService({
            url: `${url}/v1`,
            retryConfig,
            logger: this.logger,
        });
        this.token = token;
    }
    async getBalance(address) {
        const balance = await this.httpService.get({
            endpoint: `/account/balance/${this.token}?address=${address}`,
            allowedStatuses: [200, 404],
        });
        return balance.winc
            ? balance
            : {
                winc: '0',
                controlledWinc: '0',
                effectiveBalance: '0',
                givenApprovals: [],
                receivedApprovals: [],
            };
    }
    getFiatRates() {
        return this.httpService.get({
            endpoint: '/rates',
        });
    }
    getFiatToAR({ currency, }) {
        return this.httpService.get({
            endpoint: `/rates/${currency}`,
        });
    }
    getSupportedCountries() {
        return this.httpService.get({
            endpoint: '/countries',
        });
    }
    getSupportedCurrencies() {
        return this.httpService.get({
            endpoint: '/currencies',
        });
    }
    async getUploadCosts({ bytes, }) {
        const fetchPricePromises = bytes.map((byteCount) => this.httpService.get({
            endpoint: `/price/bytes/${byteCount}`,
        }));
        const wincCostsForBytes = await Promise.all(fetchPricePromises);
        return wincCostsForBytes;
    }
    getWincForFiat({ amount, promoCodes = [], nativeAddress = 'placeholder', // For price checks we only check promo code eligibility, a placeholder can be used
     }) {
        return this.httpService.get({
            endpoint: `/price/${amount.type}/${amount.amount}?destinationAddress=${nativeAddress}&${this.appendPromoCodesToQuery(promoCodes)}`,
        });
    }
    async getWincForToken({ tokenAmount, }) {
        const { actualPaymentAmount, fees, winc } = await this.httpService.get({
            endpoint: `/price/${this.token}/${tokenAmount}`,
        });
        return {
            winc,
            fees,
            actualTokenAmount: tokenAmount.toString(),
            equivalentWincTokenAmount: actualPaymentAmount.toString(),
        };
    }
    appendPromoCodesToQuery(promoCodes) {
        const promoCodesQuery = promoCodes.join(',');
        return promoCodesQuery ? `promoCode=${promoCodesQuery}` : '';
    }
    async getTurboCryptoWallets() {
        const { addresses } = await this.httpService.get({
            endpoint: '/info',
        });
        return addresses;
    }
    async getCheckout({ amount, owner, promoCodes = [], uiMode = 'hosted', }, headers) {
        const { amount: paymentAmount, type: currencyType } = amount;
        const endpoint = `/top-up/checkout-session/${owner}/${currencyType}/${paymentAmount}?uiMode=${uiMode}${promoCodes.length > 0
            ? `&${this.appendPromoCodesToQuery(promoCodes)}`
            : ''}&token=${this.token}`;
        const { adjustments, paymentSession, topUpQuote, fees } = await this.httpService.get({
            endpoint,
            headers,
        });
        return {
            winc: topUpQuote.winstonCreditAmount,
            adjustments,
            fees,
            url: paymentSession.url ?? undefined,
            id: paymentSession.id,
            client_secret: paymentSession.client_secret ?? undefined,
            /** @deprecated -- backfilled for backwards compatibility, use actualPaymentAmount */
            paymentAmount: topUpQuote.paymentAmount,
            actualPaymentAmount: topUpQuote.paymentAmount,
            quotedPaymentAmount: topUpQuote.quotedPaymentAmount,
        };
    }
    createCheckoutSession(params) {
        return this.getCheckout(params);
    }
    async submitFundTransaction({ txId, }) {
        const response = await this.httpService.post({
            endpoint: `/account/balance/${this.token}`,
            data: Buffer.from(JSON.stringify({ tx_id: txId })),
        });
        if ('creditedTransaction' in response) {
            return {
                id: response.creditedTransaction.transactionId,
                quantity: response.creditedTransaction.transactionQuantity,
                owner: response.creditedTransaction.destinationAddress,
                winc: response.creditedTransaction.winstonCreditAmount,
                token: response.creditedTransaction.tokenType,
                status: 'confirmed',
                block: response.creditedTransaction.blockHeight,
            };
        }
        else if ('pendingTransaction' in response) {
            return {
                id: response.pendingTransaction.transactionId,
                quantity: response.pendingTransaction.transactionQuantity,
                owner: response.pendingTransaction.destinationAddress,
                winc: response.pendingTransaction.winstonCreditAmount,
                token: response.pendingTransaction.tokenType,
                status: 'pending',
            };
        }
        else if ('failedTransaction' in response) {
            return {
                id: response.failedTransaction.transactionId,
                quantity: response.failedTransaction.transactionQuantity,
                owner: response.failedTransaction.destinationAddress,
                winc: response.failedTransaction.winstonCreditAmount,
                token: response.failedTransaction.tokenType,
                status: 'failed',
            };
        }
        throw new Error('Unknown response from payment service: ' + response);
    }
    async getCreditShareApprovals({ userAddress, }) {
        const response = await this.httpService.get({
            endpoint: `/account/approvals/get?userAddress=${userAddress}`,
            allowedStatuses: [200, 404],
        });
        if (response?.givenApprovals === undefined &&
            response?.receivedApprovals === undefined) {
            return {
                givenApprovals: [],
                receivedApprovals: [],
            };
        }
        return response;
    }
    async getTokenPriceForBytes({ byteCount, }) {
        const wincPriceForOneToken = (await this.getWincForToken({
            tokenAmount: tokenToBaseMap[this.token](1),
        })).winc;
        const wincPriceForOneGiB = (await this.getUploadCosts({
            bytes: [2 ** 30],
        }))[0].winc;
        const tokenPriceForOneGiB = new BigNumber(wincPriceForOneGiB).dividedBy(wincPriceForOneToken);
        const tokenPriceForBytes = tokenPriceForOneGiB
            .dividedBy(2 ** 30)
            .times(byteCount)
            .toFixed(exponentMap[this.token]);
        return { byteCount, tokenPrice: tokenPriceForBytes, token: this.token };
    }
}
// NOTE: to avoid redundancy, we use inheritance here - but generally prefer composition over inheritance
export class TurboAuthenticatedPaymentService extends TurboUnauthenticatedPaymentService {
    constructor({ url = defaultPaymentServiceURL, retryConfig, signer, logger = TurboWinstonLogger.default, token = 'arweave', tokenTools, }) {
        super({ url, retryConfig, logger, token });
        this.signer = signer;
        this.tokenTools = tokenTools;
    }
    async getBalance(userAddress) {
        userAddress ??= await this.signer.getNativeAddress();
        return super.getBalance(userAddress);
    }
    async getCreditShareApprovals({ userAddress, }) {
        userAddress ??= await this.signer.getNativeAddress();
        return super.getCreditShareApprovals({ userAddress });
    }
    async getWincForFiat({ amount, promoCodes = [], }) {
        return super.getWincForFiat({
            amount,
            promoCodes,
            nativeAddress: await this.signer.getNativeAddress(),
        });
    }
    async createCheckoutSession(params) {
        return this.getCheckout(params);
    }
    async getTargetWalletForFund() {
        const { addresses } = await this.httpService.get({
            endpoint: '/info',
        });
        const walletAddress = addresses[this.token];
        if (!walletAddress) {
            throw new Error(`No wallet address found for token type: ${this.token}`);
        }
        return walletAddress;
    }
    async topUpWithTokens({ feeMultiplier = 1, tokenAmount: tokenAmountV, }) {
        if (!this.tokenTools) {
            throw new Error(`Token type not supported for crypto fund ${this.token}`);
        }
        const tokenAmount = new BigNumber(tokenAmountV);
        const target = await this.getTargetWalletForFund();
        this.logger.debug('Funding account...', {
            feeMultiplier,
            tokenAmount,
            target,
        });
        const fundTx = await this.tokenTools.createAndSubmitTx({
            target,
            tokenAmount,
            feeMultiplier,
            signer: this.signer,
        });
        const txId = fundTx.id;
        try {
            // Let transaction settle some time
            await this.tokenTools.pollForTxBeingAvailable({ txId });
        }
        catch (e) {
            this.logger.error(`Failed to poll for transaction being available from ${this.token} gateway... Attempting to submit fund tx to Turbo...`, e);
        }
        try {
            return {
                ...(await this.submitFundTransaction({ txId })),
                target: fundTx.target,
                reward: fundTx.reward,
            };
        }
        catch (e) {
            this.logger.debug('Failed to submit fund transaction...', e);
            throw Error(`Failed to submit fund transaction! Save this Transaction ID and try again with 'turbo.submitFundTransaction(id)': ${txId}`);
        }
    }
}
