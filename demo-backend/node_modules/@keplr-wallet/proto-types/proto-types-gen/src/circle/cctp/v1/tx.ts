/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "circle.cctp.v1";

export interface MsgUpdateOwner {
  from: string;
  newOwner: string;
}

export interface MsgUpdateOwnerResponse {}

export interface MsgUpdateAttesterManager {
  from: string;
  newAttesterManager: string;
}

export interface MsgUpdateAttesterManagerResponse {}

export interface MsgUpdateTokenController {
  from: string;
  newTokenController: string;
}

export interface MsgUpdateTokenControllerResponse {}

export interface MsgUpdatePauser {
  from: string;
  newPauser: string;
}

export interface MsgUpdatePauserResponse {}

export interface MsgAcceptOwner {
  from: string;
}

export interface MsgAcceptOwnerResponse {}

export interface MsgEnableAttester {
  from: string;
  attester: string;
}

export interface MsgEnableAttesterResponse {}

export interface MsgDisableAttester {
  from: string;
  attester: string;
}

export interface MsgDisableAttesterResponse {}

export interface MsgPauseBurningAndMinting {
  from: string;
}

export interface MsgPauseBurningAndMintingResponse {}

export interface MsgUnpauseBurningAndMinting {
  from: string;
}

export interface MsgUnpauseBurningAndMintingResponse {}

export interface MsgPauseSendingAndReceivingMessages {
  from: string;
}

export interface MsgPauseSendingAndReceivingMessagesResponse {}

export interface MsgUnpauseSendingAndReceivingMessages {
  from: string;
}

export interface MsgUnpauseSendingAndReceivingMessagesResponse {}

export interface MsgUpdateMaxMessageBodySize {
  from: string;
  messageSize: string;
}

export interface MsgUpdateMaxMessageBodySizeResponse {}

export interface MsgSetMaxBurnAmountPerMessage {
  from: string;
  localToken: string;
  amount: string;
}

export interface MsgSetMaxBurnAmountPerMessageResponse {}

export interface MsgDepositForBurn {
  from: string;
  amount: string;
  destinationDomain: number;
  mintRecipient: Uint8Array;
  burnToken: string;
}

export interface MsgDepositForBurnResponse {
  nonce: string;
}

export interface MsgDepositForBurnWithCaller {
  from: string;
  amount: string;
  destinationDomain: number;
  mintRecipient: Uint8Array;
  burnToken: string;
  destinationCaller: Uint8Array;
}

export interface MsgDepositForBurnWithCallerResponse {
  nonce: string;
}

export interface MsgReplaceDepositForBurn {
  from: string;
  originalMessage: Uint8Array;
  originalAttestation: Uint8Array;
  newDestinationCaller: Uint8Array;
  newMintRecipient: Uint8Array;
}

export interface MsgReplaceDepositForBurnResponse {}

export interface MsgReceiveMessage {
  from: string;
  message: Uint8Array;
  attestation: Uint8Array;
}

export interface MsgReceiveMessageResponse {
  success: boolean;
}

export interface MsgSendMessage {
  from: string;
  destinationDomain: number;
  recipient: Uint8Array;
  messageBody: Uint8Array;
}

export interface MsgSendMessageResponse {
  nonce: string;
}

export interface MsgSendMessageWithCaller {
  from: string;
  destinationDomain: number;
  recipient: Uint8Array;
  messageBody: Uint8Array;
  destinationCaller: Uint8Array;
}

export interface MsgSendMessageWithCallerResponse {
  nonce: string;
}

export interface MsgReplaceMessage {
  from: string;
  originalMessage: Uint8Array;
  originalAttestation: Uint8Array;
  newMessageBody: Uint8Array;
  newDestinationCaller: Uint8Array;
}

export interface MsgReplaceMessageResponse {}

export interface MsgUpdateSignatureThreshold {
  from: string;
  amount: number;
}

export interface MsgUpdateSignatureThresholdResponse {}

export interface MsgLinkTokenPair {
  from: string;
  remoteDomain: number;
  remoteToken: Uint8Array;
  localToken: string;
}

export interface MsgLinkTokenPairResponse {}

export interface MsgUnlinkTokenPair {
  from: string;
  remoteDomain: number;
  remoteToken: Uint8Array;
  localToken: string;
}

export interface MsgUnlinkTokenPairResponse {}

export interface MsgAddRemoteTokenMessenger {
  from: string;
  domainId: number;
  address: Uint8Array;
}

export interface MsgAddRemoteTokenMessengerResponse {}

export interface MsgRemoveRemoteTokenMessenger {
  from: string;
  domainId: number;
}

export interface MsgRemoveRemoteTokenMessengerResponse {}

function createBaseMsgUpdateOwner(): MsgUpdateOwner {
  return { from: "", newOwner: "" };
}

export const MsgUpdateOwner = {
  encode(
    message: MsgUpdateOwner,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.newOwner !== "") {
      writer.uint32(18).string(message.newOwner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateOwner {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.newOwner = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateOwner {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      newOwner: isSet(object.newOwner) ? String(object.newOwner) : "",
    };
  },

  toJSON(message: MsgUpdateOwner): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.newOwner !== undefined && (obj.newOwner = message.newOwner);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateOwner>, I>>(
    object: I
  ): MsgUpdateOwner {
    const message = createBaseMsgUpdateOwner();
    message.from = object.from ?? "";
    message.newOwner = object.newOwner ?? "";
    return message;
  },
};

function createBaseMsgUpdateOwnerResponse(): MsgUpdateOwnerResponse {
  return {};
}

export const MsgUpdateOwnerResponse = {
  encode(
    _: MsgUpdateOwnerResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateOwnerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOwnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateOwnerResponse {
    return {};
  },

  toJSON(_: MsgUpdateOwnerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateOwnerResponse>, I>>(
    _: I
  ): MsgUpdateOwnerResponse {
    const message = createBaseMsgUpdateOwnerResponse();
    return message;
  },
};

function createBaseMsgUpdateAttesterManager(): MsgUpdateAttesterManager {
  return { from: "", newAttesterManager: "" };
}

export const MsgUpdateAttesterManager = {
  encode(
    message: MsgUpdateAttesterManager,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.newAttesterManager !== "") {
      writer.uint32(18).string(message.newAttesterManager);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateAttesterManager {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateAttesterManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.newAttesterManager = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateAttesterManager {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      newAttesterManager: isSet(object.newAttesterManager)
        ? String(object.newAttesterManager)
        : "",
    };
  },

  toJSON(message: MsgUpdateAttesterManager): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.newAttesterManager !== undefined &&
      (obj.newAttesterManager = message.newAttesterManager);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateAttesterManager>, I>>(
    object: I
  ): MsgUpdateAttesterManager {
    const message = createBaseMsgUpdateAttesterManager();
    message.from = object.from ?? "";
    message.newAttesterManager = object.newAttesterManager ?? "";
    return message;
  },
};

function createBaseMsgUpdateAttesterManagerResponse(): MsgUpdateAttesterManagerResponse {
  return {};
}

export const MsgUpdateAttesterManagerResponse = {
  encode(
    _: MsgUpdateAttesterManagerResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateAttesterManagerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateAttesterManagerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateAttesterManagerResponse {
    return {};
  },

  toJSON(_: MsgUpdateAttesterManagerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgUpdateAttesterManagerResponse>, I>
  >(_: I): MsgUpdateAttesterManagerResponse {
    const message = createBaseMsgUpdateAttesterManagerResponse();
    return message;
  },
};

function createBaseMsgUpdateTokenController(): MsgUpdateTokenController {
  return { from: "", newTokenController: "" };
}

export const MsgUpdateTokenController = {
  encode(
    message: MsgUpdateTokenController,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.newTokenController !== "") {
      writer.uint32(18).string(message.newTokenController);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateTokenController {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateTokenController();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.newTokenController = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateTokenController {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      newTokenController: isSet(object.newTokenController)
        ? String(object.newTokenController)
        : "",
    };
  },

  toJSON(message: MsgUpdateTokenController): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.newTokenController !== undefined &&
      (obj.newTokenController = message.newTokenController);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateTokenController>, I>>(
    object: I
  ): MsgUpdateTokenController {
    const message = createBaseMsgUpdateTokenController();
    message.from = object.from ?? "";
    message.newTokenController = object.newTokenController ?? "";
    return message;
  },
};

function createBaseMsgUpdateTokenControllerResponse(): MsgUpdateTokenControllerResponse {
  return {};
}

export const MsgUpdateTokenControllerResponse = {
  encode(
    _: MsgUpdateTokenControllerResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateTokenControllerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateTokenControllerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateTokenControllerResponse {
    return {};
  },

  toJSON(_: MsgUpdateTokenControllerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgUpdateTokenControllerResponse>, I>
  >(_: I): MsgUpdateTokenControllerResponse {
    const message = createBaseMsgUpdateTokenControllerResponse();
    return message;
  },
};

function createBaseMsgUpdatePauser(): MsgUpdatePauser {
  return { from: "", newPauser: "" };
}

export const MsgUpdatePauser = {
  encode(
    message: MsgUpdatePauser,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.newPauser !== "") {
      writer.uint32(18).string(message.newPauser);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdatePauser {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdatePauser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.newPauser = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdatePauser {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      newPauser: isSet(object.newPauser) ? String(object.newPauser) : "",
    };
  },

  toJSON(message: MsgUpdatePauser): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.newPauser !== undefined && (obj.newPauser = message.newPauser);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdatePauser>, I>>(
    object: I
  ): MsgUpdatePauser {
    const message = createBaseMsgUpdatePauser();
    message.from = object.from ?? "";
    message.newPauser = object.newPauser ?? "";
    return message;
  },
};

function createBaseMsgUpdatePauserResponse(): MsgUpdatePauserResponse {
  return {};
}

export const MsgUpdatePauserResponse = {
  encode(
    _: MsgUpdatePauserResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdatePauserResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdatePauserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdatePauserResponse {
    return {};
  },

  toJSON(_: MsgUpdatePauserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdatePauserResponse>, I>>(
    _: I
  ): MsgUpdatePauserResponse {
    const message = createBaseMsgUpdatePauserResponse();
    return message;
  },
};

function createBaseMsgAcceptOwner(): MsgAcceptOwner {
  return { from: "" };
}

export const MsgAcceptOwner = {
  encode(
    message: MsgAcceptOwner,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAcceptOwner {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAcceptOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgAcceptOwner {
    return {
      from: isSet(object.from) ? String(object.from) : "",
    };
  },

  toJSON(message: MsgAcceptOwner): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgAcceptOwner>, I>>(
    object: I
  ): MsgAcceptOwner {
    const message = createBaseMsgAcceptOwner();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseMsgAcceptOwnerResponse(): MsgAcceptOwnerResponse {
  return {};
}

export const MsgAcceptOwnerResponse = {
  encode(
    _: MsgAcceptOwnerResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgAcceptOwnerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAcceptOwnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgAcceptOwnerResponse {
    return {};
  },

  toJSON(_: MsgAcceptOwnerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgAcceptOwnerResponse>, I>>(
    _: I
  ): MsgAcceptOwnerResponse {
    const message = createBaseMsgAcceptOwnerResponse();
    return message;
  },
};

function createBaseMsgEnableAttester(): MsgEnableAttester {
  return { from: "", attester: "" };
}

export const MsgEnableAttester = {
  encode(
    message: MsgEnableAttester,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.attester !== "") {
      writer.uint32(18).string(message.attester);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgEnableAttester {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEnableAttester();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.attester = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgEnableAttester {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      attester: isSet(object.attester) ? String(object.attester) : "",
    };
  },

  toJSON(message: MsgEnableAttester): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.attester !== undefined && (obj.attester = message.attester);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgEnableAttester>, I>>(
    object: I
  ): MsgEnableAttester {
    const message = createBaseMsgEnableAttester();
    message.from = object.from ?? "";
    message.attester = object.attester ?? "";
    return message;
  },
};

function createBaseMsgEnableAttesterResponse(): MsgEnableAttesterResponse {
  return {};
}

export const MsgEnableAttesterResponse = {
  encode(
    _: MsgEnableAttesterResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgEnableAttesterResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEnableAttesterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgEnableAttesterResponse {
    return {};
  },

  toJSON(_: MsgEnableAttesterResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgEnableAttesterResponse>, I>>(
    _: I
  ): MsgEnableAttesterResponse {
    const message = createBaseMsgEnableAttesterResponse();
    return message;
  },
};

function createBaseMsgDisableAttester(): MsgDisableAttester {
  return { from: "", attester: "" };
}

export const MsgDisableAttester = {
  encode(
    message: MsgDisableAttester,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.attester !== "") {
      writer.uint32(18).string(message.attester);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDisableAttester {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDisableAttester();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.attester = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgDisableAttester {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      attester: isSet(object.attester) ? String(object.attester) : "",
    };
  },

  toJSON(message: MsgDisableAttester): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.attester !== undefined && (obj.attester = message.attester);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgDisableAttester>, I>>(
    object: I
  ): MsgDisableAttester {
    const message = createBaseMsgDisableAttester();
    message.from = object.from ?? "";
    message.attester = object.attester ?? "";
    return message;
  },
};

function createBaseMsgDisableAttesterResponse(): MsgDisableAttesterResponse {
  return {};
}

export const MsgDisableAttesterResponse = {
  encode(
    _: MsgDisableAttesterResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgDisableAttesterResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDisableAttesterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgDisableAttesterResponse {
    return {};
  },

  toJSON(_: MsgDisableAttesterResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgDisableAttesterResponse>, I>>(
    _: I
  ): MsgDisableAttesterResponse {
    const message = createBaseMsgDisableAttesterResponse();
    return message;
  },
};

function createBaseMsgPauseBurningAndMinting(): MsgPauseBurningAndMinting {
  return { from: "" };
}

export const MsgPauseBurningAndMinting = {
  encode(
    message: MsgPauseBurningAndMinting,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgPauseBurningAndMinting {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPauseBurningAndMinting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgPauseBurningAndMinting {
    return {
      from: isSet(object.from) ? String(object.from) : "",
    };
  },

  toJSON(message: MsgPauseBurningAndMinting): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgPauseBurningAndMinting>, I>>(
    object: I
  ): MsgPauseBurningAndMinting {
    const message = createBaseMsgPauseBurningAndMinting();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseMsgPauseBurningAndMintingResponse(): MsgPauseBurningAndMintingResponse {
  return {};
}

export const MsgPauseBurningAndMintingResponse = {
  encode(
    _: MsgPauseBurningAndMintingResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgPauseBurningAndMintingResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPauseBurningAndMintingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgPauseBurningAndMintingResponse {
    return {};
  },

  toJSON(_: MsgPauseBurningAndMintingResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgPauseBurningAndMintingResponse>, I>
  >(_: I): MsgPauseBurningAndMintingResponse {
    const message = createBaseMsgPauseBurningAndMintingResponse();
    return message;
  },
};

function createBaseMsgUnpauseBurningAndMinting(): MsgUnpauseBurningAndMinting {
  return { from: "" };
}

export const MsgUnpauseBurningAndMinting = {
  encode(
    message: MsgUnpauseBurningAndMinting,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUnpauseBurningAndMinting {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnpauseBurningAndMinting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUnpauseBurningAndMinting {
    return {
      from: isSet(object.from) ? String(object.from) : "",
    };
  },

  toJSON(message: MsgUnpauseBurningAndMinting): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUnpauseBurningAndMinting>, I>>(
    object: I
  ): MsgUnpauseBurningAndMinting {
    const message = createBaseMsgUnpauseBurningAndMinting();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseMsgUnpauseBurningAndMintingResponse(): MsgUnpauseBurningAndMintingResponse {
  return {};
}

export const MsgUnpauseBurningAndMintingResponse = {
  encode(
    _: MsgUnpauseBurningAndMintingResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUnpauseBurningAndMintingResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnpauseBurningAndMintingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUnpauseBurningAndMintingResponse {
    return {};
  },

  toJSON(_: MsgUnpauseBurningAndMintingResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgUnpauseBurningAndMintingResponse>, I>
  >(_: I): MsgUnpauseBurningAndMintingResponse {
    const message = createBaseMsgUnpauseBurningAndMintingResponse();
    return message;
  },
};

function createBaseMsgPauseSendingAndReceivingMessages(): MsgPauseSendingAndReceivingMessages {
  return { from: "" };
}

export const MsgPauseSendingAndReceivingMessages = {
  encode(
    message: MsgPauseSendingAndReceivingMessages,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgPauseSendingAndReceivingMessages {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPauseSendingAndReceivingMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgPauseSendingAndReceivingMessages {
    return {
      from: isSet(object.from) ? String(object.from) : "",
    };
  },

  toJSON(message: MsgPauseSendingAndReceivingMessages): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgPauseSendingAndReceivingMessages>, I>
  >(object: I): MsgPauseSendingAndReceivingMessages {
    const message = createBaseMsgPauseSendingAndReceivingMessages();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseMsgPauseSendingAndReceivingMessagesResponse(): MsgPauseSendingAndReceivingMessagesResponse {
  return {};
}

export const MsgPauseSendingAndReceivingMessagesResponse = {
  encode(
    _: MsgPauseSendingAndReceivingMessagesResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgPauseSendingAndReceivingMessagesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPauseSendingAndReceivingMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgPauseSendingAndReceivingMessagesResponse {
    return {};
  },

  toJSON(_: MsgPauseSendingAndReceivingMessagesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgPauseSendingAndReceivingMessagesResponse>, I>
  >(_: I): MsgPauseSendingAndReceivingMessagesResponse {
    const message = createBaseMsgPauseSendingAndReceivingMessagesResponse();
    return message;
  },
};

function createBaseMsgUnpauseSendingAndReceivingMessages(): MsgUnpauseSendingAndReceivingMessages {
  return { from: "" };
}

export const MsgUnpauseSendingAndReceivingMessages = {
  encode(
    message: MsgUnpauseSendingAndReceivingMessages,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUnpauseSendingAndReceivingMessages {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnpauseSendingAndReceivingMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUnpauseSendingAndReceivingMessages {
    return {
      from: isSet(object.from) ? String(object.from) : "",
    };
  },

  toJSON(message: MsgUnpauseSendingAndReceivingMessages): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgUnpauseSendingAndReceivingMessages>, I>
  >(object: I): MsgUnpauseSendingAndReceivingMessages {
    const message = createBaseMsgUnpauseSendingAndReceivingMessages();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseMsgUnpauseSendingAndReceivingMessagesResponse(): MsgUnpauseSendingAndReceivingMessagesResponse {
  return {};
}

export const MsgUnpauseSendingAndReceivingMessagesResponse = {
  encode(
    _: MsgUnpauseSendingAndReceivingMessagesResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUnpauseSendingAndReceivingMessagesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnpauseSendingAndReceivingMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUnpauseSendingAndReceivingMessagesResponse {
    return {};
  },

  toJSON(_: MsgUnpauseSendingAndReceivingMessagesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<
      DeepPartial<MsgUnpauseSendingAndReceivingMessagesResponse>,
      I
    >
  >(_: I): MsgUnpauseSendingAndReceivingMessagesResponse {
    const message = createBaseMsgUnpauseSendingAndReceivingMessagesResponse();
    return message;
  },
};

function createBaseMsgUpdateMaxMessageBodySize(): MsgUpdateMaxMessageBodySize {
  return { from: "", messageSize: "0" };
}

export const MsgUpdateMaxMessageBodySize = {
  encode(
    message: MsgUpdateMaxMessageBodySize,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.messageSize !== "0") {
      writer.uint32(16).uint64(message.messageSize);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateMaxMessageBodySize {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateMaxMessageBodySize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.messageSize = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateMaxMessageBodySize {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      messageSize: isSet(object.messageSize) ? String(object.messageSize) : "0",
    };
  },

  toJSON(message: MsgUpdateMaxMessageBodySize): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.messageSize !== undefined &&
      (obj.messageSize = message.messageSize);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateMaxMessageBodySize>, I>>(
    object: I
  ): MsgUpdateMaxMessageBodySize {
    const message = createBaseMsgUpdateMaxMessageBodySize();
    message.from = object.from ?? "";
    message.messageSize = object.messageSize ?? "0";
    return message;
  },
};

function createBaseMsgUpdateMaxMessageBodySizeResponse(): MsgUpdateMaxMessageBodySizeResponse {
  return {};
}

export const MsgUpdateMaxMessageBodySizeResponse = {
  encode(
    _: MsgUpdateMaxMessageBodySizeResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateMaxMessageBodySizeResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateMaxMessageBodySizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateMaxMessageBodySizeResponse {
    return {};
  },

  toJSON(_: MsgUpdateMaxMessageBodySizeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgUpdateMaxMessageBodySizeResponse>, I>
  >(_: I): MsgUpdateMaxMessageBodySizeResponse {
    const message = createBaseMsgUpdateMaxMessageBodySizeResponse();
    return message;
  },
};

function createBaseMsgSetMaxBurnAmountPerMessage(): MsgSetMaxBurnAmountPerMessage {
  return { from: "", localToken: "", amount: "" };
}

export const MsgSetMaxBurnAmountPerMessage = {
  encode(
    message: MsgSetMaxBurnAmountPerMessage,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.localToken !== "") {
      writer.uint32(18).string(message.localToken);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgSetMaxBurnAmountPerMessage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMaxBurnAmountPerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.localToken = reader.string();
          break;
        case 3:
          message.amount = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSetMaxBurnAmountPerMessage {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      localToken: isSet(object.localToken) ? String(object.localToken) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
    };
  },

  toJSON(message: MsgSetMaxBurnAmountPerMessage): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.localToken !== undefined && (obj.localToken = message.localToken);
    message.amount !== undefined && (obj.amount = message.amount);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSetMaxBurnAmountPerMessage>, I>>(
    object: I
  ): MsgSetMaxBurnAmountPerMessage {
    const message = createBaseMsgSetMaxBurnAmountPerMessage();
    message.from = object.from ?? "";
    message.localToken = object.localToken ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgSetMaxBurnAmountPerMessageResponse(): MsgSetMaxBurnAmountPerMessageResponse {
  return {};
}

export const MsgSetMaxBurnAmountPerMessageResponse = {
  encode(
    _: MsgSetMaxBurnAmountPerMessageResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgSetMaxBurnAmountPerMessageResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMaxBurnAmountPerMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgSetMaxBurnAmountPerMessageResponse {
    return {};
  },

  toJSON(_: MsgSetMaxBurnAmountPerMessageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgSetMaxBurnAmountPerMessageResponse>, I>
  >(_: I): MsgSetMaxBurnAmountPerMessageResponse {
    const message = createBaseMsgSetMaxBurnAmountPerMessageResponse();
    return message;
  },
};

function createBaseMsgDepositForBurn(): MsgDepositForBurn {
  return {
    from: "",
    amount: "",
    destinationDomain: 0,
    mintRecipient: new Uint8Array(),
    burnToken: "",
  };
}

export const MsgDepositForBurn = {
  encode(
    message: MsgDepositForBurn,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.destinationDomain !== 0) {
      writer.uint32(24).uint32(message.destinationDomain);
    }
    if (message.mintRecipient.length !== 0) {
      writer.uint32(34).bytes(message.mintRecipient);
    }
    if (message.burnToken !== "") {
      writer.uint32(42).string(message.burnToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDepositForBurn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDepositForBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.amount = reader.string();
          break;
        case 3:
          message.destinationDomain = reader.uint32();
          break;
        case 4:
          message.mintRecipient = reader.bytes();
          break;
        case 5:
          message.burnToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgDepositForBurn {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
      destinationDomain: isSet(object.destinationDomain)
        ? Number(object.destinationDomain)
        : 0,
      mintRecipient: isSet(object.mintRecipient)
        ? bytesFromBase64(object.mintRecipient)
        : new Uint8Array(),
      burnToken: isSet(object.burnToken) ? String(object.burnToken) : "",
    };
  },

  toJSON(message: MsgDepositForBurn): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.amount !== undefined && (obj.amount = message.amount);
    message.destinationDomain !== undefined &&
      (obj.destinationDomain = Math.round(message.destinationDomain));
    message.mintRecipient !== undefined &&
      (obj.mintRecipient = base64FromBytes(
        message.mintRecipient !== undefined
          ? message.mintRecipient
          : new Uint8Array()
      ));
    message.burnToken !== undefined && (obj.burnToken = message.burnToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgDepositForBurn>, I>>(
    object: I
  ): MsgDepositForBurn {
    const message = createBaseMsgDepositForBurn();
    message.from = object.from ?? "";
    message.amount = object.amount ?? "";
    message.destinationDomain = object.destinationDomain ?? 0;
    message.mintRecipient = object.mintRecipient ?? new Uint8Array();
    message.burnToken = object.burnToken ?? "";
    return message;
  },
};

function createBaseMsgDepositForBurnResponse(): MsgDepositForBurnResponse {
  return { nonce: "0" };
}

export const MsgDepositForBurnResponse = {
  encode(
    message: MsgDepositForBurnResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.nonce !== "0") {
      writer.uint32(8).uint64(message.nonce);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgDepositForBurnResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDepositForBurnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nonce = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgDepositForBurnResponse {
    return {
      nonce: isSet(object.nonce) ? String(object.nonce) : "0",
    };
  },

  toJSON(message: MsgDepositForBurnResponse): unknown {
    const obj: any = {};
    message.nonce !== undefined && (obj.nonce = message.nonce);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgDepositForBurnResponse>, I>>(
    object: I
  ): MsgDepositForBurnResponse {
    const message = createBaseMsgDepositForBurnResponse();
    message.nonce = object.nonce ?? "0";
    return message;
  },
};

function createBaseMsgDepositForBurnWithCaller(): MsgDepositForBurnWithCaller {
  return {
    from: "",
    amount: "",
    destinationDomain: 0,
    mintRecipient: new Uint8Array(),
    burnToken: "",
    destinationCaller: new Uint8Array(),
  };
}

export const MsgDepositForBurnWithCaller = {
  encode(
    message: MsgDepositForBurnWithCaller,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.destinationDomain !== 0) {
      writer.uint32(24).uint32(message.destinationDomain);
    }
    if (message.mintRecipient.length !== 0) {
      writer.uint32(34).bytes(message.mintRecipient);
    }
    if (message.burnToken !== "") {
      writer.uint32(42).string(message.burnToken);
    }
    if (message.destinationCaller.length !== 0) {
      writer.uint32(50).bytes(message.destinationCaller);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgDepositForBurnWithCaller {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDepositForBurnWithCaller();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.amount = reader.string();
          break;
        case 3:
          message.destinationDomain = reader.uint32();
          break;
        case 4:
          message.mintRecipient = reader.bytes();
          break;
        case 5:
          message.burnToken = reader.string();
          break;
        case 6:
          message.destinationCaller = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgDepositForBurnWithCaller {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
      destinationDomain: isSet(object.destinationDomain)
        ? Number(object.destinationDomain)
        : 0,
      mintRecipient: isSet(object.mintRecipient)
        ? bytesFromBase64(object.mintRecipient)
        : new Uint8Array(),
      burnToken: isSet(object.burnToken) ? String(object.burnToken) : "",
      destinationCaller: isSet(object.destinationCaller)
        ? bytesFromBase64(object.destinationCaller)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgDepositForBurnWithCaller): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.amount !== undefined && (obj.amount = message.amount);
    message.destinationDomain !== undefined &&
      (obj.destinationDomain = Math.round(message.destinationDomain));
    message.mintRecipient !== undefined &&
      (obj.mintRecipient = base64FromBytes(
        message.mintRecipient !== undefined
          ? message.mintRecipient
          : new Uint8Array()
      ));
    message.burnToken !== undefined && (obj.burnToken = message.burnToken);
    message.destinationCaller !== undefined &&
      (obj.destinationCaller = base64FromBytes(
        message.destinationCaller !== undefined
          ? message.destinationCaller
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgDepositForBurnWithCaller>, I>>(
    object: I
  ): MsgDepositForBurnWithCaller {
    const message = createBaseMsgDepositForBurnWithCaller();
    message.from = object.from ?? "";
    message.amount = object.amount ?? "";
    message.destinationDomain = object.destinationDomain ?? 0;
    message.mintRecipient = object.mintRecipient ?? new Uint8Array();
    message.burnToken = object.burnToken ?? "";
    message.destinationCaller = object.destinationCaller ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgDepositForBurnWithCallerResponse(): MsgDepositForBurnWithCallerResponse {
  return { nonce: "0" };
}

export const MsgDepositForBurnWithCallerResponse = {
  encode(
    message: MsgDepositForBurnWithCallerResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.nonce !== "0") {
      writer.uint32(8).uint64(message.nonce);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgDepositForBurnWithCallerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDepositForBurnWithCallerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nonce = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgDepositForBurnWithCallerResponse {
    return {
      nonce: isSet(object.nonce) ? String(object.nonce) : "0",
    };
  },

  toJSON(message: MsgDepositForBurnWithCallerResponse): unknown {
    const obj: any = {};
    message.nonce !== undefined && (obj.nonce = message.nonce);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgDepositForBurnWithCallerResponse>, I>
  >(object: I): MsgDepositForBurnWithCallerResponse {
    const message = createBaseMsgDepositForBurnWithCallerResponse();
    message.nonce = object.nonce ?? "0";
    return message;
  },
};

function createBaseMsgReplaceDepositForBurn(): MsgReplaceDepositForBurn {
  return {
    from: "",
    originalMessage: new Uint8Array(),
    originalAttestation: new Uint8Array(),
    newDestinationCaller: new Uint8Array(),
    newMintRecipient: new Uint8Array(),
  };
}

export const MsgReplaceDepositForBurn = {
  encode(
    message: MsgReplaceDepositForBurn,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.originalMessage.length !== 0) {
      writer.uint32(18).bytes(message.originalMessage);
    }
    if (message.originalAttestation.length !== 0) {
      writer.uint32(26).bytes(message.originalAttestation);
    }
    if (message.newDestinationCaller.length !== 0) {
      writer.uint32(34).bytes(message.newDestinationCaller);
    }
    if (message.newMintRecipient.length !== 0) {
      writer.uint32(42).bytes(message.newMintRecipient);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgReplaceDepositForBurn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReplaceDepositForBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.originalMessage = reader.bytes();
          break;
        case 3:
          message.originalAttestation = reader.bytes();
          break;
        case 4:
          message.newDestinationCaller = reader.bytes();
          break;
        case 5:
          message.newMintRecipient = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgReplaceDepositForBurn {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      originalMessage: isSet(object.originalMessage)
        ? bytesFromBase64(object.originalMessage)
        : new Uint8Array(),
      originalAttestation: isSet(object.originalAttestation)
        ? bytesFromBase64(object.originalAttestation)
        : new Uint8Array(),
      newDestinationCaller: isSet(object.newDestinationCaller)
        ? bytesFromBase64(object.newDestinationCaller)
        : new Uint8Array(),
      newMintRecipient: isSet(object.newMintRecipient)
        ? bytesFromBase64(object.newMintRecipient)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgReplaceDepositForBurn): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.originalMessage !== undefined &&
      (obj.originalMessage = base64FromBytes(
        message.originalMessage !== undefined
          ? message.originalMessage
          : new Uint8Array()
      ));
    message.originalAttestation !== undefined &&
      (obj.originalAttestation = base64FromBytes(
        message.originalAttestation !== undefined
          ? message.originalAttestation
          : new Uint8Array()
      ));
    message.newDestinationCaller !== undefined &&
      (obj.newDestinationCaller = base64FromBytes(
        message.newDestinationCaller !== undefined
          ? message.newDestinationCaller
          : new Uint8Array()
      ));
    message.newMintRecipient !== undefined &&
      (obj.newMintRecipient = base64FromBytes(
        message.newMintRecipient !== undefined
          ? message.newMintRecipient
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgReplaceDepositForBurn>, I>>(
    object: I
  ): MsgReplaceDepositForBurn {
    const message = createBaseMsgReplaceDepositForBurn();
    message.from = object.from ?? "";
    message.originalMessage = object.originalMessage ?? new Uint8Array();
    message.originalAttestation =
      object.originalAttestation ?? new Uint8Array();
    message.newDestinationCaller =
      object.newDestinationCaller ?? new Uint8Array();
    message.newMintRecipient = object.newMintRecipient ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgReplaceDepositForBurnResponse(): MsgReplaceDepositForBurnResponse {
  return {};
}

export const MsgReplaceDepositForBurnResponse = {
  encode(
    _: MsgReplaceDepositForBurnResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgReplaceDepositForBurnResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReplaceDepositForBurnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgReplaceDepositForBurnResponse {
    return {};
  },

  toJSON(_: MsgReplaceDepositForBurnResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgReplaceDepositForBurnResponse>, I>
  >(_: I): MsgReplaceDepositForBurnResponse {
    const message = createBaseMsgReplaceDepositForBurnResponse();
    return message;
  },
};

function createBaseMsgReceiveMessage(): MsgReceiveMessage {
  return { from: "", message: new Uint8Array(), attestation: new Uint8Array() };
}

export const MsgReceiveMessage = {
  encode(
    message: MsgReceiveMessage,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.message.length !== 0) {
      writer.uint32(18).bytes(message.message);
    }
    if (message.attestation.length !== 0) {
      writer.uint32(26).bytes(message.attestation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgReceiveMessage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReceiveMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.message = reader.bytes();
          break;
        case 3:
          message.attestation = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgReceiveMessage {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      message: isSet(object.message)
        ? bytesFromBase64(object.message)
        : new Uint8Array(),
      attestation: isSet(object.attestation)
        ? bytesFromBase64(object.attestation)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgReceiveMessage): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.message !== undefined &&
      (obj.message = base64FromBytes(
        message.message !== undefined ? message.message : new Uint8Array()
      ));
    message.attestation !== undefined &&
      (obj.attestation = base64FromBytes(
        message.attestation !== undefined
          ? message.attestation
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgReceiveMessage>, I>>(
    object: I
  ): MsgReceiveMessage {
    const message = createBaseMsgReceiveMessage();
    message.from = object.from ?? "";
    message.message = object.message ?? new Uint8Array();
    message.attestation = object.attestation ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgReceiveMessageResponse(): MsgReceiveMessageResponse {
  return { success: false };
}

export const MsgReceiveMessageResponse = {
  encode(
    message: MsgReceiveMessageResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgReceiveMessageResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReceiveMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgReceiveMessageResponse {
    return {
      success: isSet(object.success) ? Boolean(object.success) : false,
    };
  },

  toJSON(message: MsgReceiveMessageResponse): unknown {
    const obj: any = {};
    message.success !== undefined && (obj.success = message.success);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgReceiveMessageResponse>, I>>(
    object: I
  ): MsgReceiveMessageResponse {
    const message = createBaseMsgReceiveMessageResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseMsgSendMessage(): MsgSendMessage {
  return {
    from: "",
    destinationDomain: 0,
    recipient: new Uint8Array(),
    messageBody: new Uint8Array(),
  };
}

export const MsgSendMessage = {
  encode(
    message: MsgSendMessage,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.destinationDomain !== 0) {
      writer.uint32(16).uint32(message.destinationDomain);
    }
    if (message.recipient.length !== 0) {
      writer.uint32(26).bytes(message.recipient);
    }
    if (message.messageBody.length !== 0) {
      writer.uint32(34).bytes(message.messageBody);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSendMessage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.destinationDomain = reader.uint32();
          break;
        case 3:
          message.recipient = reader.bytes();
          break;
        case 4:
          message.messageBody = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSendMessage {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      destinationDomain: isSet(object.destinationDomain)
        ? Number(object.destinationDomain)
        : 0,
      recipient: isSet(object.recipient)
        ? bytesFromBase64(object.recipient)
        : new Uint8Array(),
      messageBody: isSet(object.messageBody)
        ? bytesFromBase64(object.messageBody)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgSendMessage): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.destinationDomain !== undefined &&
      (obj.destinationDomain = Math.round(message.destinationDomain));
    message.recipient !== undefined &&
      (obj.recipient = base64FromBytes(
        message.recipient !== undefined ? message.recipient : new Uint8Array()
      ));
    message.messageBody !== undefined &&
      (obj.messageBody = base64FromBytes(
        message.messageBody !== undefined
          ? message.messageBody
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSendMessage>, I>>(
    object: I
  ): MsgSendMessage {
    const message = createBaseMsgSendMessage();
    message.from = object.from ?? "";
    message.destinationDomain = object.destinationDomain ?? 0;
    message.recipient = object.recipient ?? new Uint8Array();
    message.messageBody = object.messageBody ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgSendMessageResponse(): MsgSendMessageResponse {
  return { nonce: "0" };
}

export const MsgSendMessageResponse = {
  encode(
    message: MsgSendMessageResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.nonce !== "0") {
      writer.uint32(8).uint64(message.nonce);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgSendMessageResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nonce = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSendMessageResponse {
    return {
      nonce: isSet(object.nonce) ? String(object.nonce) : "0",
    };
  },

  toJSON(message: MsgSendMessageResponse): unknown {
    const obj: any = {};
    message.nonce !== undefined && (obj.nonce = message.nonce);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSendMessageResponse>, I>>(
    object: I
  ): MsgSendMessageResponse {
    const message = createBaseMsgSendMessageResponse();
    message.nonce = object.nonce ?? "0";
    return message;
  },
};

function createBaseMsgSendMessageWithCaller(): MsgSendMessageWithCaller {
  return {
    from: "",
    destinationDomain: 0,
    recipient: new Uint8Array(),
    messageBody: new Uint8Array(),
    destinationCaller: new Uint8Array(),
  };
}

export const MsgSendMessageWithCaller = {
  encode(
    message: MsgSendMessageWithCaller,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.destinationDomain !== 0) {
      writer.uint32(16).uint32(message.destinationDomain);
    }
    if (message.recipient.length !== 0) {
      writer.uint32(26).bytes(message.recipient);
    }
    if (message.messageBody.length !== 0) {
      writer.uint32(34).bytes(message.messageBody);
    }
    if (message.destinationCaller.length !== 0) {
      writer.uint32(42).bytes(message.destinationCaller);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgSendMessageWithCaller {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendMessageWithCaller();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.destinationDomain = reader.uint32();
          break;
        case 3:
          message.recipient = reader.bytes();
          break;
        case 4:
          message.messageBody = reader.bytes();
          break;
        case 5:
          message.destinationCaller = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSendMessageWithCaller {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      destinationDomain: isSet(object.destinationDomain)
        ? Number(object.destinationDomain)
        : 0,
      recipient: isSet(object.recipient)
        ? bytesFromBase64(object.recipient)
        : new Uint8Array(),
      messageBody: isSet(object.messageBody)
        ? bytesFromBase64(object.messageBody)
        : new Uint8Array(),
      destinationCaller: isSet(object.destinationCaller)
        ? bytesFromBase64(object.destinationCaller)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgSendMessageWithCaller): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.destinationDomain !== undefined &&
      (obj.destinationDomain = Math.round(message.destinationDomain));
    message.recipient !== undefined &&
      (obj.recipient = base64FromBytes(
        message.recipient !== undefined ? message.recipient : new Uint8Array()
      ));
    message.messageBody !== undefined &&
      (obj.messageBody = base64FromBytes(
        message.messageBody !== undefined
          ? message.messageBody
          : new Uint8Array()
      ));
    message.destinationCaller !== undefined &&
      (obj.destinationCaller = base64FromBytes(
        message.destinationCaller !== undefined
          ? message.destinationCaller
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSendMessageWithCaller>, I>>(
    object: I
  ): MsgSendMessageWithCaller {
    const message = createBaseMsgSendMessageWithCaller();
    message.from = object.from ?? "";
    message.destinationDomain = object.destinationDomain ?? 0;
    message.recipient = object.recipient ?? new Uint8Array();
    message.messageBody = object.messageBody ?? new Uint8Array();
    message.destinationCaller = object.destinationCaller ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgSendMessageWithCallerResponse(): MsgSendMessageWithCallerResponse {
  return { nonce: "0" };
}

export const MsgSendMessageWithCallerResponse = {
  encode(
    message: MsgSendMessageWithCallerResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.nonce !== "0") {
      writer.uint32(8).uint64(message.nonce);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgSendMessageWithCallerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendMessageWithCallerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nonce = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSendMessageWithCallerResponse {
    return {
      nonce: isSet(object.nonce) ? String(object.nonce) : "0",
    };
  },

  toJSON(message: MsgSendMessageWithCallerResponse): unknown {
    const obj: any = {};
    message.nonce !== undefined && (obj.nonce = message.nonce);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgSendMessageWithCallerResponse>, I>
  >(object: I): MsgSendMessageWithCallerResponse {
    const message = createBaseMsgSendMessageWithCallerResponse();
    message.nonce = object.nonce ?? "0";
    return message;
  },
};

function createBaseMsgReplaceMessage(): MsgReplaceMessage {
  return {
    from: "",
    originalMessage: new Uint8Array(),
    originalAttestation: new Uint8Array(),
    newMessageBody: new Uint8Array(),
    newDestinationCaller: new Uint8Array(),
  };
}

export const MsgReplaceMessage = {
  encode(
    message: MsgReplaceMessage,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.originalMessage.length !== 0) {
      writer.uint32(18).bytes(message.originalMessage);
    }
    if (message.originalAttestation.length !== 0) {
      writer.uint32(26).bytes(message.originalAttestation);
    }
    if (message.newMessageBody.length !== 0) {
      writer.uint32(34).bytes(message.newMessageBody);
    }
    if (message.newDestinationCaller.length !== 0) {
      writer.uint32(42).bytes(message.newDestinationCaller);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgReplaceMessage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReplaceMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.originalMessage = reader.bytes();
          break;
        case 3:
          message.originalAttestation = reader.bytes();
          break;
        case 4:
          message.newMessageBody = reader.bytes();
          break;
        case 5:
          message.newDestinationCaller = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgReplaceMessage {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      originalMessage: isSet(object.originalMessage)
        ? bytesFromBase64(object.originalMessage)
        : new Uint8Array(),
      originalAttestation: isSet(object.originalAttestation)
        ? bytesFromBase64(object.originalAttestation)
        : new Uint8Array(),
      newMessageBody: isSet(object.newMessageBody)
        ? bytesFromBase64(object.newMessageBody)
        : new Uint8Array(),
      newDestinationCaller: isSet(object.newDestinationCaller)
        ? bytesFromBase64(object.newDestinationCaller)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgReplaceMessage): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.originalMessage !== undefined &&
      (obj.originalMessage = base64FromBytes(
        message.originalMessage !== undefined
          ? message.originalMessage
          : new Uint8Array()
      ));
    message.originalAttestation !== undefined &&
      (obj.originalAttestation = base64FromBytes(
        message.originalAttestation !== undefined
          ? message.originalAttestation
          : new Uint8Array()
      ));
    message.newMessageBody !== undefined &&
      (obj.newMessageBody = base64FromBytes(
        message.newMessageBody !== undefined
          ? message.newMessageBody
          : new Uint8Array()
      ));
    message.newDestinationCaller !== undefined &&
      (obj.newDestinationCaller = base64FromBytes(
        message.newDestinationCaller !== undefined
          ? message.newDestinationCaller
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgReplaceMessage>, I>>(
    object: I
  ): MsgReplaceMessage {
    const message = createBaseMsgReplaceMessage();
    message.from = object.from ?? "";
    message.originalMessage = object.originalMessage ?? new Uint8Array();
    message.originalAttestation =
      object.originalAttestation ?? new Uint8Array();
    message.newMessageBody = object.newMessageBody ?? new Uint8Array();
    message.newDestinationCaller =
      object.newDestinationCaller ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgReplaceMessageResponse(): MsgReplaceMessageResponse {
  return {};
}

export const MsgReplaceMessageResponse = {
  encode(
    _: MsgReplaceMessageResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgReplaceMessageResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReplaceMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgReplaceMessageResponse {
    return {};
  },

  toJSON(_: MsgReplaceMessageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgReplaceMessageResponse>, I>>(
    _: I
  ): MsgReplaceMessageResponse {
    const message = createBaseMsgReplaceMessageResponse();
    return message;
  },
};

function createBaseMsgUpdateSignatureThreshold(): MsgUpdateSignatureThreshold {
  return { from: "", amount: 0 };
}

export const MsgUpdateSignatureThreshold = {
  encode(
    message: MsgUpdateSignatureThreshold,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint32(message.amount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateSignatureThreshold {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSignatureThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.amount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateSignatureThreshold {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      amount: isSet(object.amount) ? Number(object.amount) : 0,
    };
  },

  toJSON(message: MsgUpdateSignatureThreshold): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.amount !== undefined && (obj.amount = Math.round(message.amount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateSignatureThreshold>, I>>(
    object: I
  ): MsgUpdateSignatureThreshold {
    const message = createBaseMsgUpdateSignatureThreshold();
    message.from = object.from ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseMsgUpdateSignatureThresholdResponse(): MsgUpdateSignatureThresholdResponse {
  return {};
}

export const MsgUpdateSignatureThresholdResponse = {
  encode(
    _: MsgUpdateSignatureThresholdResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateSignatureThresholdResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSignatureThresholdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateSignatureThresholdResponse {
    return {};
  },

  toJSON(_: MsgUpdateSignatureThresholdResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgUpdateSignatureThresholdResponse>, I>
  >(_: I): MsgUpdateSignatureThresholdResponse {
    const message = createBaseMsgUpdateSignatureThresholdResponse();
    return message;
  },
};

function createBaseMsgLinkTokenPair(): MsgLinkTokenPair {
  return {
    from: "",
    remoteDomain: 0,
    remoteToken: new Uint8Array(),
    localToken: "",
  };
}

export const MsgLinkTokenPair = {
  encode(
    message: MsgLinkTokenPair,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.remoteDomain !== 0) {
      writer.uint32(16).uint32(message.remoteDomain);
    }
    if (message.remoteToken.length !== 0) {
      writer.uint32(26).bytes(message.remoteToken);
    }
    if (message.localToken !== "") {
      writer.uint32(34).string(message.localToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgLinkTokenPair {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgLinkTokenPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.remoteDomain = reader.uint32();
          break;
        case 3:
          message.remoteToken = reader.bytes();
          break;
        case 4:
          message.localToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgLinkTokenPair {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      remoteDomain: isSet(object.remoteDomain)
        ? Number(object.remoteDomain)
        : 0,
      remoteToken: isSet(object.remoteToken)
        ? bytesFromBase64(object.remoteToken)
        : new Uint8Array(),
      localToken: isSet(object.localToken) ? String(object.localToken) : "",
    };
  },

  toJSON(message: MsgLinkTokenPair): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.remoteDomain !== undefined &&
      (obj.remoteDomain = Math.round(message.remoteDomain));
    message.remoteToken !== undefined &&
      (obj.remoteToken = base64FromBytes(
        message.remoteToken !== undefined
          ? message.remoteToken
          : new Uint8Array()
      ));
    message.localToken !== undefined && (obj.localToken = message.localToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgLinkTokenPair>, I>>(
    object: I
  ): MsgLinkTokenPair {
    const message = createBaseMsgLinkTokenPair();
    message.from = object.from ?? "";
    message.remoteDomain = object.remoteDomain ?? 0;
    message.remoteToken = object.remoteToken ?? new Uint8Array();
    message.localToken = object.localToken ?? "";
    return message;
  },
};

function createBaseMsgLinkTokenPairResponse(): MsgLinkTokenPairResponse {
  return {};
}

export const MsgLinkTokenPairResponse = {
  encode(
    _: MsgLinkTokenPairResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgLinkTokenPairResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgLinkTokenPairResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgLinkTokenPairResponse {
    return {};
  },

  toJSON(_: MsgLinkTokenPairResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgLinkTokenPairResponse>, I>>(
    _: I
  ): MsgLinkTokenPairResponse {
    const message = createBaseMsgLinkTokenPairResponse();
    return message;
  },
};

function createBaseMsgUnlinkTokenPair(): MsgUnlinkTokenPair {
  return {
    from: "",
    remoteDomain: 0,
    remoteToken: new Uint8Array(),
    localToken: "",
  };
}

export const MsgUnlinkTokenPair = {
  encode(
    message: MsgUnlinkTokenPair,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.remoteDomain !== 0) {
      writer.uint32(16).uint32(message.remoteDomain);
    }
    if (message.remoteToken.length !== 0) {
      writer.uint32(26).bytes(message.remoteToken);
    }
    if (message.localToken !== "") {
      writer.uint32(34).string(message.localToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUnlinkTokenPair {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnlinkTokenPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.remoteDomain = reader.uint32();
          break;
        case 3:
          message.remoteToken = reader.bytes();
          break;
        case 4:
          message.localToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUnlinkTokenPair {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      remoteDomain: isSet(object.remoteDomain)
        ? Number(object.remoteDomain)
        : 0,
      remoteToken: isSet(object.remoteToken)
        ? bytesFromBase64(object.remoteToken)
        : new Uint8Array(),
      localToken: isSet(object.localToken) ? String(object.localToken) : "",
    };
  },

  toJSON(message: MsgUnlinkTokenPair): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.remoteDomain !== undefined &&
      (obj.remoteDomain = Math.round(message.remoteDomain));
    message.remoteToken !== undefined &&
      (obj.remoteToken = base64FromBytes(
        message.remoteToken !== undefined
          ? message.remoteToken
          : new Uint8Array()
      ));
    message.localToken !== undefined && (obj.localToken = message.localToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUnlinkTokenPair>, I>>(
    object: I
  ): MsgUnlinkTokenPair {
    const message = createBaseMsgUnlinkTokenPair();
    message.from = object.from ?? "";
    message.remoteDomain = object.remoteDomain ?? 0;
    message.remoteToken = object.remoteToken ?? new Uint8Array();
    message.localToken = object.localToken ?? "";
    return message;
  },
};

function createBaseMsgUnlinkTokenPairResponse(): MsgUnlinkTokenPairResponse {
  return {};
}

export const MsgUnlinkTokenPairResponse = {
  encode(
    _: MsgUnlinkTokenPairResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUnlinkTokenPairResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnlinkTokenPairResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUnlinkTokenPairResponse {
    return {};
  },

  toJSON(_: MsgUnlinkTokenPairResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUnlinkTokenPairResponse>, I>>(
    _: I
  ): MsgUnlinkTokenPairResponse {
    const message = createBaseMsgUnlinkTokenPairResponse();
    return message;
  },
};

function createBaseMsgAddRemoteTokenMessenger(): MsgAddRemoteTokenMessenger {
  return { from: "", domainId: 0, address: new Uint8Array() };
}

export const MsgAddRemoteTokenMessenger = {
  encode(
    message: MsgAddRemoteTokenMessenger,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.domainId !== 0) {
      writer.uint32(16).uint32(message.domainId);
    }
    if (message.address.length !== 0) {
      writer.uint32(26).bytes(message.address);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgAddRemoteTokenMessenger {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddRemoteTokenMessenger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.domainId = reader.uint32();
          break;
        case 3:
          message.address = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgAddRemoteTokenMessenger {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      domainId: isSet(object.domainId) ? Number(object.domainId) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgAddRemoteTokenMessenger): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.domainId !== undefined &&
      (obj.domainId = Math.round(message.domainId));
    message.address !== undefined &&
      (obj.address = base64FromBytes(
        message.address !== undefined ? message.address : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgAddRemoteTokenMessenger>, I>>(
    object: I
  ): MsgAddRemoteTokenMessenger {
    const message = createBaseMsgAddRemoteTokenMessenger();
    message.from = object.from ?? "";
    message.domainId = object.domainId ?? 0;
    message.address = object.address ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgAddRemoteTokenMessengerResponse(): MsgAddRemoteTokenMessengerResponse {
  return {};
}

export const MsgAddRemoteTokenMessengerResponse = {
  encode(
    _: MsgAddRemoteTokenMessengerResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgAddRemoteTokenMessengerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddRemoteTokenMessengerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgAddRemoteTokenMessengerResponse {
    return {};
  },

  toJSON(_: MsgAddRemoteTokenMessengerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgAddRemoteTokenMessengerResponse>, I>
  >(_: I): MsgAddRemoteTokenMessengerResponse {
    const message = createBaseMsgAddRemoteTokenMessengerResponse();
    return message;
  },
};

function createBaseMsgRemoveRemoteTokenMessenger(): MsgRemoveRemoteTokenMessenger {
  return { from: "", domainId: 0 };
}

export const MsgRemoveRemoteTokenMessenger = {
  encode(
    message: MsgRemoveRemoteTokenMessenger,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.domainId !== 0) {
      writer.uint32(16).uint32(message.domainId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgRemoveRemoteTokenMessenger {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveRemoteTokenMessenger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.from = reader.string();
          break;
        case 2:
          message.domainId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveRemoteTokenMessenger {
    return {
      from: isSet(object.from) ? String(object.from) : "",
      domainId: isSet(object.domainId) ? Number(object.domainId) : 0,
    };
  },

  toJSON(message: MsgRemoveRemoteTokenMessenger): unknown {
    const obj: any = {};
    message.from !== undefined && (obj.from = message.from);
    message.domainId !== undefined &&
      (obj.domainId = Math.round(message.domainId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgRemoveRemoteTokenMessenger>, I>>(
    object: I
  ): MsgRemoveRemoteTokenMessenger {
    const message = createBaseMsgRemoveRemoteTokenMessenger();
    message.from = object.from ?? "";
    message.domainId = object.domainId ?? 0;
    return message;
  },
};

function createBaseMsgRemoveRemoteTokenMessengerResponse(): MsgRemoveRemoteTokenMessengerResponse {
  return {};
}

export const MsgRemoveRemoteTokenMessengerResponse = {
  encode(
    _: MsgRemoveRemoteTokenMessengerResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgRemoveRemoteTokenMessengerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveRemoteTokenMessengerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveRemoteTokenMessengerResponse {
    return {};
  },

  toJSON(_: MsgRemoveRemoteTokenMessengerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgRemoveRemoteTokenMessengerResponse>, I>
  >(_: I): MsgRemoveRemoteTokenMessengerResponse {
    const message = createBaseMsgRemoveRemoteTokenMessengerResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  AcceptOwner(request: MsgAcceptOwner): Promise<MsgAcceptOwnerResponse>;
  AddRemoteTokenMessenger(
    request: MsgAddRemoteTokenMessenger
  ): Promise<MsgAddRemoteTokenMessengerResponse>;
  DepositForBurn(
    request: MsgDepositForBurn
  ): Promise<MsgDepositForBurnResponse>;
  DepositForBurnWithCaller(
    request: MsgDepositForBurnWithCaller
  ): Promise<MsgDepositForBurnWithCallerResponse>;
  DisableAttester(
    request: MsgDisableAttester
  ): Promise<MsgDisableAttesterResponse>;
  EnableAttester(
    request: MsgEnableAttester
  ): Promise<MsgEnableAttesterResponse>;
  LinkTokenPair(request: MsgLinkTokenPair): Promise<MsgLinkTokenPairResponse>;
  PauseBurningAndMinting(
    request: MsgPauseBurningAndMinting
  ): Promise<MsgPauseBurningAndMintingResponse>;
  PauseSendingAndReceivingMessages(
    request: MsgPauseSendingAndReceivingMessages
  ): Promise<MsgPauseSendingAndReceivingMessagesResponse>;
  ReceiveMessage(
    request: MsgReceiveMessage
  ): Promise<MsgReceiveMessageResponse>;
  RemoveRemoteTokenMessenger(
    request: MsgRemoveRemoteTokenMessenger
  ): Promise<MsgRemoveRemoteTokenMessengerResponse>;
  ReplaceDepositForBurn(
    request: MsgReplaceDepositForBurn
  ): Promise<MsgReplaceDepositForBurnResponse>;
  ReplaceMessage(
    request: MsgReplaceMessage
  ): Promise<MsgReplaceMessageResponse>;
  SendMessage(request: MsgSendMessage): Promise<MsgSendMessageResponse>;
  SendMessageWithCaller(
    request: MsgSendMessageWithCaller
  ): Promise<MsgSendMessageWithCallerResponse>;
  UnlinkTokenPair(
    request: MsgUnlinkTokenPair
  ): Promise<MsgUnlinkTokenPairResponse>;
  UnpauseBurningAndMinting(
    request: MsgUnpauseBurningAndMinting
  ): Promise<MsgUnpauseBurningAndMintingResponse>;
  UnpauseSendingAndReceivingMessages(
    request: MsgUnpauseSendingAndReceivingMessages
  ): Promise<MsgUnpauseSendingAndReceivingMessagesResponse>;
  UpdateOwner(request: MsgUpdateOwner): Promise<MsgUpdateOwnerResponse>;
  UpdateAttesterManager(
    request: MsgUpdateAttesterManager
  ): Promise<MsgUpdateAttesterManagerResponse>;
  UpdateTokenController(
    request: MsgUpdateTokenController
  ): Promise<MsgUpdateTokenControllerResponse>;
  UpdatePauser(request: MsgUpdatePauser): Promise<MsgUpdatePauserResponse>;
  UpdateMaxMessageBodySize(
    request: MsgUpdateMaxMessageBodySize
  ): Promise<MsgUpdateMaxMessageBodySizeResponse>;
  SetMaxBurnAmountPerMessage(
    request: MsgSetMaxBurnAmountPerMessage
  ): Promise<MsgSetMaxBurnAmountPerMessageResponse>;
  UpdateSignatureThreshold(
    request: MsgUpdateSignatureThreshold
  ): Promise<MsgUpdateSignatureThresholdResponse>;
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

const atob: (b64: string) => string =
  globalThis.atob ||
  ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64: string): Uint8Array {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

const btoa: (bin: string) => string =
  globalThis.btoa ||
  ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  for (const byte of arr) {
    bin.push(String.fromCharCode(byte));
  }
  return btoa(bin.join(""));
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
