"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgSetOperatorAddressResponse = exports.MsgSetOperatorAddress = exports.MsgOverwriteRedemptionRecordResponse = exports.MsgOverwriteRedemptionRecord = exports.MsgOverwriteUnbondingRecordResponse = exports.MsgOverwriteUnbondingRecord = exports.MsgOverwriteDelegationRecordResponse = exports.MsgOverwriteDelegationRecord = exports.MsgRefreshRedemptionRateResponse = exports.MsgRefreshRedemptionRate = exports.MsgResumeHostZoneResponse = exports.MsgResumeHostZone = exports.MsgUpdateInnerRedemptionRateBoundsResponse = exports.MsgUpdateInnerRedemptionRateBounds = exports.MsgAdjustDelegatedBalanceResponse = exports.MsgAdjustDelegatedBalance = exports.MsgConfirmUnbondedTokenSweepResponse = exports.MsgConfirmUnbondedTokenSweep = exports.MsgConfirmUndelegationResponse = exports.MsgConfirmUndelegation = exports.MsgConfirmDelegationResponse = exports.MsgConfirmDelegation = exports.MsgRedeemStakeResponse = exports.MsgRedeemStake = exports.MsgLiquidStakeResponse = exports.MsgLiquidStake = exports.overwritableRecordTypeToJSON = exports.overwritableRecordTypeFromJSON = exports.OverwritableRecordType = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../cosmos/base/v1beta1/coin");
const staketia_1 = require("../../stride/staketia/staketia");
exports.protobufPackage = "stride.staketia";
var OverwritableRecordType;
(function (OverwritableRecordType) {
    OverwritableRecordType[OverwritableRecordType["RECORD_TYPE_DELEGATION"] = 0] = "RECORD_TYPE_DELEGATION";
    OverwritableRecordType[OverwritableRecordType["RECORD_TYPE_UNBONDING"] = 1] = "RECORD_TYPE_UNBONDING";
    OverwritableRecordType[OverwritableRecordType["RECORD_TYPE_REDEMPTION"] = 2] = "RECORD_TYPE_REDEMPTION";
    OverwritableRecordType[OverwritableRecordType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OverwritableRecordType = exports.OverwritableRecordType || (exports.OverwritableRecordType = {}));
function overwritableRecordTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "RECORD_TYPE_DELEGATION":
            return OverwritableRecordType.RECORD_TYPE_DELEGATION;
        case 1:
        case "RECORD_TYPE_UNBONDING":
            return OverwritableRecordType.RECORD_TYPE_UNBONDING;
        case 2:
        case "RECORD_TYPE_REDEMPTION":
            return OverwritableRecordType.RECORD_TYPE_REDEMPTION;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OverwritableRecordType.UNRECOGNIZED;
    }
}
exports.overwritableRecordTypeFromJSON = overwritableRecordTypeFromJSON;
function overwritableRecordTypeToJSON(object) {
    switch (object) {
        case OverwritableRecordType.RECORD_TYPE_DELEGATION:
            return "RECORD_TYPE_DELEGATION";
        case OverwritableRecordType.RECORD_TYPE_UNBONDING:
            return "RECORD_TYPE_UNBONDING";
        case OverwritableRecordType.RECORD_TYPE_REDEMPTION:
            return "RECORD_TYPE_REDEMPTION";
        default:
            return "UNKNOWN";
    }
}
exports.overwritableRecordTypeToJSON = overwritableRecordTypeToJSON;
function createBaseMsgLiquidStake() {
    return { staker: "", nativeAmount: "" };
}
exports.MsgLiquidStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.staker !== "") {
            writer.uint32(10).string(message.staker);
        }
        if (message.nativeAmount !== "") {
            writer.uint32(18).string(message.nativeAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStake();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.staker = reader.string();
                    break;
                case 2:
                    message.nativeAmount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            staker: isSet(object.staker) ? String(object.staker) : "",
            nativeAmount: isSet(object.nativeAmount)
                ? String(object.nativeAmount)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.staker !== undefined && (obj.staker = message.staker);
        message.nativeAmount !== undefined &&
            (obj.nativeAmount = message.nativeAmount);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgLiquidStake();
        message.staker = (_a = object.staker) !== null && _a !== void 0 ? _a : "";
        message.nativeAmount = (_b = object.nativeAmount) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgLiquidStakeResponse() {
    return { stToken: undefined };
}
exports.MsgLiquidStakeResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.stToken !== undefined) {
            coin_1.Coin.encode(message.stToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStakeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stToken = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            stToken: isSet(object.stToken)
                ? coin_1.Coin.fromJSON(object.stToken)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.stToken !== undefined &&
            (obj.stToken = message.stToken
                ? coin_1.Coin.toJSON(message.stToken)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMsgLiquidStakeResponse();
        message.stToken =
            object.stToken !== undefined && object.stToken !== null
                ? coin_1.Coin.fromPartial(object.stToken)
                : undefined;
        return message;
    },
};
function createBaseMsgRedeemStake() {
    return { redeemer: "", stTokenAmount: "" };
}
exports.MsgRedeemStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redeemer !== "") {
            writer.uint32(10).string(message.redeemer);
        }
        if (message.stTokenAmount !== "") {
            writer.uint32(18).string(message.stTokenAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStake();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.redeemer = reader.string();
                    break;
                case 2:
                    message.stTokenAmount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            redeemer: isSet(object.redeemer) ? String(object.redeemer) : "",
            stTokenAmount: isSet(object.stTokenAmount)
                ? String(object.stTokenAmount)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.redeemer !== undefined && (obj.redeemer = message.redeemer);
        message.stTokenAmount !== undefined &&
            (obj.stTokenAmount = message.stTokenAmount);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgRedeemStake();
        message.redeemer = (_a = object.redeemer) !== null && _a !== void 0 ? _a : "";
        message.stTokenAmount = (_b = object.stTokenAmount) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgRedeemStakeResponse() {
    return { nativeToken: undefined };
}
exports.MsgRedeemStakeResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nativeToken !== undefined) {
            coin_1.Coin.encode(message.nativeToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStakeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nativeToken = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            nativeToken: isSet(object.nativeToken)
                ? coin_1.Coin.fromJSON(object.nativeToken)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.nativeToken !== undefined &&
            (obj.nativeToken = message.nativeToken
                ? coin_1.Coin.toJSON(message.nativeToken)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMsgRedeemStakeResponse();
        message.nativeToken =
            object.nativeToken !== undefined && object.nativeToken !== null
                ? coin_1.Coin.fromPartial(object.nativeToken)
                : undefined;
        return message;
    },
};
function createBaseMsgConfirmDelegation() {
    return { operator: "", recordId: "0", txHash: "" };
}
exports.MsgConfirmDelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
            writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
            writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
            writer.uint32(26).string(message.txHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmDelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.operator = reader.string();
                    break;
                case 2:
                    message.recordId = longToString(reader.uint64());
                    break;
                case 3:
                    message.txHash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            operator: isSet(object.operator) ? String(object.operator) : "",
            recordId: isSet(object.recordId) ? String(object.recordId) : "0",
            txHash: isSet(object.txHash) ? String(object.txHash) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.operator !== undefined && (obj.operator = message.operator);
        message.recordId !== undefined && (obj.recordId = message.recordId);
        message.txHash !== undefined && (obj.txHash = message.txHash);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgConfirmDelegation();
        message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgConfirmDelegationResponse() {
    return {};
}
exports.MsgConfirmDelegationResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmDelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgConfirmDelegationResponse();
        return message;
    },
};
function createBaseMsgConfirmUndelegation() {
    return { operator: "", recordId: "0", txHash: "" };
}
exports.MsgConfirmUndelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
            writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
            writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
            writer.uint32(26).string(message.txHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUndelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.operator = reader.string();
                    break;
                case 2:
                    message.recordId = longToString(reader.uint64());
                    break;
                case 3:
                    message.txHash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            operator: isSet(object.operator) ? String(object.operator) : "",
            recordId: isSet(object.recordId) ? String(object.recordId) : "0",
            txHash: isSet(object.txHash) ? String(object.txHash) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.operator !== undefined && (obj.operator = message.operator);
        message.recordId !== undefined && (obj.recordId = message.recordId);
        message.txHash !== undefined && (obj.txHash = message.txHash);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgConfirmUndelegation();
        message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgConfirmUndelegationResponse() {
    return {};
}
exports.MsgConfirmUndelegationResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUndelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgConfirmUndelegationResponse();
        return message;
    },
};
function createBaseMsgConfirmUnbondedTokenSweep() {
    return { operator: "", recordId: "0", txHash: "" };
}
exports.MsgConfirmUnbondedTokenSweep = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
            writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
            writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
            writer.uint32(26).string(message.txHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUnbondedTokenSweep();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.operator = reader.string();
                    break;
                case 2:
                    message.recordId = longToString(reader.uint64());
                    break;
                case 3:
                    message.txHash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            operator: isSet(object.operator) ? String(object.operator) : "",
            recordId: isSet(object.recordId) ? String(object.recordId) : "0",
            txHash: isSet(object.txHash) ? String(object.txHash) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.operator !== undefined && (obj.operator = message.operator);
        message.recordId !== undefined && (obj.recordId = message.recordId);
        message.txHash !== undefined && (obj.txHash = message.txHash);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgConfirmUnbondedTokenSweep();
        message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgConfirmUnbondedTokenSweepResponse() {
    return {};
}
exports.MsgConfirmUnbondedTokenSweepResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUnbondedTokenSweepResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgConfirmUnbondedTokenSweepResponse();
        return message;
    },
};
function createBaseMsgAdjustDelegatedBalance() {
    return { operator: "", delegationOffset: "", validatorAddress: "" };
}
exports.MsgAdjustDelegatedBalance = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
            writer.uint32(10).string(message.operator);
        }
        if (message.delegationOffset !== "") {
            writer.uint32(18).string(message.delegationOffset);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(26).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAdjustDelegatedBalance();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.operator = reader.string();
                    break;
                case 2:
                    message.delegationOffset = reader.string();
                    break;
                case 3:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            operator: isSet(object.operator) ? String(object.operator) : "",
            delegationOffset: isSet(object.delegationOffset)
                ? String(object.delegationOffset)
                : "",
            validatorAddress: isSet(object.validatorAddress)
                ? String(object.validatorAddress)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.operator !== undefined && (obj.operator = message.operator);
        message.delegationOffset !== undefined &&
            (obj.delegationOffset = message.delegationOffset);
        message.validatorAddress !== undefined &&
            (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgAdjustDelegatedBalance();
        message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : "";
        message.delegationOffset = (_b = object.delegationOffset) !== null && _b !== void 0 ? _b : "";
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgAdjustDelegatedBalanceResponse() {
    return {};
}
exports.MsgAdjustDelegatedBalanceResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAdjustDelegatedBalanceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgAdjustDelegatedBalanceResponse();
        return message;
    },
};
function createBaseMsgUpdateInnerRedemptionRateBounds() {
    return {
        creator: "",
        minInnerRedemptionRate: "",
        maxInnerRedemptionRate: "",
    };
}
exports.MsgUpdateInnerRedemptionRateBounds = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.minInnerRedemptionRate !== "") {
            writer.uint32(18).string(message.minInnerRedemptionRate);
        }
        if (message.maxInnerRedemptionRate !== "") {
            writer.uint32(26).string(message.maxInnerRedemptionRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.minInnerRedemptionRate = reader.string();
                    break;
                case 3:
                    message.maxInnerRedemptionRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            minInnerRedemptionRate: isSet(object.minInnerRedemptionRate)
                ? String(object.minInnerRedemptionRate)
                : "",
            maxInnerRedemptionRate: isSet(object.maxInnerRedemptionRate)
                ? String(object.maxInnerRedemptionRate)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.minInnerRedemptionRate !== undefined &&
            (obj.minInnerRedemptionRate = message.minInnerRedemptionRate);
        message.maxInnerRedemptionRate !== undefined &&
            (obj.maxInnerRedemptionRate = message.maxInnerRedemptionRate);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.minInnerRedemptionRate = (_b = object.minInnerRedemptionRate) !== null && _b !== void 0 ? _b : "";
        message.maxInnerRedemptionRate = (_c = object.maxInnerRedemptionRate) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgUpdateInnerRedemptionRateBoundsResponse() {
    return {};
}
exports.MsgUpdateInnerRedemptionRateBoundsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        return message;
    },
};
function createBaseMsgResumeHostZone() {
    return { creator: "" };
}
exports.MsgResumeHostZone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgResumeHostZone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgResumeHostZone();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseMsgResumeHostZoneResponse() {
    return {};
}
exports.MsgResumeHostZoneResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgResumeHostZoneResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgResumeHostZoneResponse();
        return message;
    },
};
function createBaseMsgRefreshRedemptionRate() {
    return { creator: "" };
}
exports.MsgRefreshRedemptionRate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRefreshRedemptionRate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgRefreshRedemptionRate();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseMsgRefreshRedemptionRateResponse() {
    return {};
}
exports.MsgRefreshRedemptionRateResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRefreshRedemptionRateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgRefreshRedemptionRateResponse();
        return message;
    },
};
function createBaseMsgOverwriteDelegationRecord() {
    return { creator: "", delegationRecord: undefined };
}
exports.MsgOverwriteDelegationRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.delegationRecord !== undefined) {
            staketia_1.DelegationRecord.encode(message.delegationRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteDelegationRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.delegationRecord = staketia_1.DelegationRecord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            delegationRecord: isSet(object.delegationRecord)
                ? staketia_1.DelegationRecord.fromJSON(object.delegationRecord)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.delegationRecord !== undefined &&
            (obj.delegationRecord = message.delegationRecord
                ? staketia_1.DelegationRecord.toJSON(message.delegationRecord)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgOverwriteDelegationRecord();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.delegationRecord =
            object.delegationRecord !== undefined && object.delegationRecord !== null
                ? staketia_1.DelegationRecord.fromPartial(object.delegationRecord)
                : undefined;
        return message;
    },
};
function createBaseMsgOverwriteDelegationRecordResponse() {
    return {};
}
exports.MsgOverwriteDelegationRecordResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteDelegationRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgOverwriteDelegationRecordResponse();
        return message;
    },
};
function createBaseMsgOverwriteUnbondingRecord() {
    return { creator: "", unbondingRecord: undefined };
}
exports.MsgOverwriteUnbondingRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.unbondingRecord !== undefined) {
            staketia_1.UnbondingRecord.encode(message.unbondingRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteUnbondingRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.unbondingRecord = staketia_1.UnbondingRecord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            unbondingRecord: isSet(object.unbondingRecord)
                ? staketia_1.UnbondingRecord.fromJSON(object.unbondingRecord)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.unbondingRecord !== undefined &&
            (obj.unbondingRecord = message.unbondingRecord
                ? staketia_1.UnbondingRecord.toJSON(message.unbondingRecord)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgOverwriteUnbondingRecord();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.unbondingRecord =
            object.unbondingRecord !== undefined && object.unbondingRecord !== null
                ? staketia_1.UnbondingRecord.fromPartial(object.unbondingRecord)
                : undefined;
        return message;
    },
};
function createBaseMsgOverwriteUnbondingRecordResponse() {
    return {};
}
exports.MsgOverwriteUnbondingRecordResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteUnbondingRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgOverwriteUnbondingRecordResponse();
        return message;
    },
};
function createBaseMsgOverwriteRedemptionRecord() {
    return { creator: "", redemptionRecord: undefined };
}
exports.MsgOverwriteRedemptionRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.redemptionRecord !== undefined) {
            staketia_1.RedemptionRecord.encode(message.redemptionRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteRedemptionRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.redemptionRecord = staketia_1.RedemptionRecord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            redemptionRecord: isSet(object.redemptionRecord)
                ? staketia_1.RedemptionRecord.fromJSON(object.redemptionRecord)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.redemptionRecord !== undefined &&
            (obj.redemptionRecord = message.redemptionRecord
                ? staketia_1.RedemptionRecord.toJSON(message.redemptionRecord)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgOverwriteRedemptionRecord();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.redemptionRecord =
            object.redemptionRecord !== undefined && object.redemptionRecord !== null
                ? staketia_1.RedemptionRecord.fromPartial(object.redemptionRecord)
                : undefined;
        return message;
    },
};
function createBaseMsgOverwriteRedemptionRecordResponse() {
    return {};
}
exports.MsgOverwriteRedemptionRecordResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteRedemptionRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgOverwriteRedemptionRecordResponse();
        return message;
    },
};
function createBaseMsgSetOperatorAddress() {
    return { signer: "", operator: "" };
}
exports.MsgSetOperatorAddress = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.operator !== "") {
            writer.uint32(18).string(message.operator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOperatorAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signer = reader.string();
                    break;
                case 2:
                    message.operator = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            signer: isSet(object.signer) ? String(object.signer) : "",
            operator: isSet(object.operator) ? String(object.operator) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.signer !== undefined && (obj.signer = message.signer);
        message.operator !== undefined && (obj.operator = message.operator);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSetOperatorAddress();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.operator = (_b = object.operator) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgSetOperatorAddressResponse() {
    return {};
}
exports.MsgSetOperatorAddressResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOperatorAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgSetOperatorAddressResponse();
        return message;
    },
};
function longToString(long) {
    return long.toString();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=tx.js.map