"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleFetch = exports.makeURL = void 0;
const error_1 = require("./error");
function makeURL(baseURL, url) {
    const baseURLInstance = new URL(baseURL);
    baseURL = removeLastSlashIfIs(baseURLInstance.origin);
    url =
        removeLastSlashIfIs(baseURLInstance.pathname) +
            "/" +
            removeFirstSlashIfIs(url);
    url =
        url +
            (() => {
                if (Array.from(baseURLInstance.searchParams.keys()).length > 0) {
                    if (url.includes("?")) {
                        return "&" + baseURLInstance.searchParams.toString();
                    }
                    else {
                        return "?" + baseURLInstance.searchParams.toString();
                    }
                }
                return "";
            })();
    return removeLastSlashIfIs(baseURL + "/" + removeFirstSlashIfIs(url));
}
exports.makeURL = makeURL;
function removeFirstSlashIfIs(str) {
    if (str.length > 0 && str[0] === "/") {
        return str.slice(1);
    }
    return str;
}
function removeLastSlashIfIs(str) {
    if (str.length > 0 && str[str.length - 1] === "/") {
        return str.slice(0, str.length - 1);
    }
    return str;
}
function simpleFetch(baseURL, url, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof url !== "string") {
            if (url) {
                options = url;
            }
            url = "";
        }
        if (url === "/") {
            // If url is "/", probably its mean should be to use only base url.
            // However, `URL` with "/" url generate the root url with removing trailing url from base url.
            // To prevent this invalid case, just handle "/" as "".
            url = "";
        }
        const actualURL = makeURL(baseURL, url);
        const _a = options || {}, { headers: optionHeaders } = _a, otherOptions = __rest(_a, ["headers"]);
        const fetched = yield fetch(actualURL, Object.assign({ headers: Object.assign({ accept: "application/json, text/plain, */*" }, optionHeaders) }, otherOptions));
        let data;
        if (fetched.status === 204) {
            // 204 No Content
            data = undefined;
        }
        else {
            const contentType = fetched.headers.get("content-type") || "";
            if (contentType.startsWith("application/json")) {
                data = yield fetched.json();
            }
            else {
                const r = yield fetched.text();
                const trim = r.trim();
                if (trim.startsWith("{") && trim.endsWith("}")) {
                    data = JSON.parse(trim);
                }
                else {
                    data = r;
                }
            }
        }
        const res = {
            url: actualURL,
            data,
            headers: fetched.headers,
            status: fetched.status,
            statusText: fetched.statusText,
        };
        const validateStatusFn = (options === null || options === void 0 ? void 0 : options.validateStatus) || defaultValidateStatusFn;
        if (!validateStatusFn(fetched.status)) {
            throw new error_1.SimpleFetchError(baseURL, url, res);
        }
        return res;
    });
}
exports.simpleFetch = simpleFetch;
function defaultValidateStatusFn(status) {
    return status >= 200 && status < 300;
}
//# sourceMappingURL=fetch.js.map