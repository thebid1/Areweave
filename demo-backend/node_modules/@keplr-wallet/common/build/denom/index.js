"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DenomHelper = void 0;
const buffer_1 = require("buffer/");
const crypto_1 = require("@keplr-wallet/crypto");
class DenomHelper {
    static ibcDenom(paths, coinMinimalDenom) {
        const prefixes = [];
        for (const path of paths) {
            prefixes.push(`${path.portId}/${path.channelId}`);
        }
        const prefix = prefixes.join("/");
        const denom = `${prefix}/${coinMinimalDenom}`;
        return ("ibc/" +
            buffer_1.Buffer.from(crypto_1.Hash.sha256(buffer_1.Buffer.from(denom)))
                .toString("hex")
                .toUpperCase());
    }
    constructor(_denom) {
        this._denom = _denom;
        // Remember that the coin's actual denom should start with "type:contractAddress" or "type:contractAddress:symbol" if it is for the token based on contract.
        let split = this.denom.split(/^(\w+):(\w+)$/).filter(Boolean);
        if (split.length !== 2) {
            split = this.denom.split(/^(\w+):(\w+):(.+)$/).filter(Boolean);
            if (split.length !== 1 && split.length !== 3) {
                throw new Error(`Invalid denom: ${this.denom}`);
            }
        }
        this._type = split.length >= 2 ? split[0] : "";
        this._contractAddress = split.length >= 2 ? split[1] : "";
    }
    get denom() {
        return this._denom;
    }
    get type() {
        return this._type || "native";
    }
    get contractAddress() {
        return this._contractAddress;
    }
}
exports.DenomHelper = DenomHelper;
//# sourceMappingURL=index.js.map