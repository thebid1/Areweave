"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KyveToken = exports.KYVEToTokenAmount = exports.ukyveToTokenAmount = void 0;
exports.signerFromKyvePrivateKey = signerFromKyvePrivateKey;
exports.privateKeyFromKyveMnemonic = privateKeyFromKyveMnemonic;
exports.signerFromKyveMnemonic = signerFromKyveMnemonic;
/**
 * Copyright (C) 2022-2024 Permanent Data Solutions, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const amino_1 = require("@cosmjs/amino");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const arbundles_1 = require("@dha-team/arbundles");
const bignumber_js_1 = require("bignumber.js");
const axiosClient_js_1 = require("../../utils/axiosClient.js");
const common_js_1 = require("../../utils/common.js");
const logger_js_1 = require("../logger.js");
function hasKyveTxResponse(response) {
    return response.tx_response !== undefined;
}
const ukyveToTokenAmount = (winston) => winston;
exports.ukyveToTokenAmount = ukyveToTokenAmount;
const KYVEToTokenAmount = (sol) => new bignumber_js_1.BigNumber(sol).times(1e6).valueOf();
exports.KYVEToTokenAmount = KYVEToTokenAmount;
class KyveToken {
    constructor({ logger = logger_js_1.TurboWinstonLogger.default, gatewayUrl = 'https://api.kyve.network/', pollingOptions = {
        maxAttempts: 5,
        pollingIntervalMs: 1_000,
        initialBackoffMs: 500,
    }, }) {
        this.logger = logger;
        this.gatewayUrl = gatewayUrl;
        this.pollingOptions = pollingOptions;
    }
    async createAndSubmitTx({ target, tokenAmount, signer, }) {
        const id = await signer.sendTransaction({
            amount: tokenAmount,
            target,
            gatewayUrl: this.gatewayUrl,
        });
        return { id, target };
    }
    async pollForTxBeingAvailable({ txId, }) {
        const { maxAttempts, pollingIntervalMs, initialBackoffMs } = this.pollingOptions;
        this.logger.debug('Polling for transaction...', {
            txId,
            pollingOptions: this.pollingOptions,
        });
        await (0, common_js_1.sleep)(initialBackoffMs);
        let attempts = 0;
        while (attempts < maxAttempts) {
            let res = undefined;
            attempts++;
            const axios = (0, axiosClient_js_1.createAxiosInstance)({
                axiosConfig: { baseURL: this.gatewayUrl },
            });
            try {
                res = await axios.get('cosmos/tx/v1beta1/txs/' + txId);
            }
            catch (err) {
                // Continue retries when request errors
                this.logger.debug('Failed to poll for transaction...', { err });
            }
            const data = res?.data;
            if (data !== undefined && hasKyveTxResponse(data)) {
                if (data.tx_response.code !== 0) {
                    throw new Error(`Transaction failed: ${data.tx_response.code}`);
                }
                return;
            }
            this.logger.debug('Transaction not found, polling...', {
                txId,
                attempts,
                maxAttempts,
                pollingIntervalMs,
            });
            await (0, common_js_1.sleep)(pollingIntervalMs);
        }
        throw new Error('Transaction not found after polling, transaction id: ' + txId);
    }
}
exports.KyveToken = KyveToken;
function signerFromKyvePrivateKey(privateKey) {
    // TODO: Use KyveSigner when implemented for on chain native address support
    return new arbundles_1.EthereumSigner(privateKey);
}
async function privateKeyFromKyveMnemonic(mnemonic) {
    const kyveWallet = await amino_1.Secp256k1HdWallet.fromMnemonic(mnemonic, {
        prefix: 'kyve',
    });
    return (0, encoding_1.toHex)(crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, kyveWallet['seed'], (0, amino_1.makeCosmoshubPath)(0)).privkey);
}
async function signerFromKyveMnemonic(mnemonic) {
    const privateKey = await privateKeyFromKyveMnemonic(mnemonic);
    return signerFromKyvePrivateKey(privateKey);
}
