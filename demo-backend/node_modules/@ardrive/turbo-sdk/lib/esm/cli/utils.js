/**
 * Copyright (C) 2022-2024 Permanent Data Solutions, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import bs58 from 'bs58';
import { readFileSync, statSync } from 'fs';
import { TurboFactory, defaultTurboConfiguration, developmentTurboConfiguration, isTokenType, privateKeyFromKyveMnemonic, } from '../node/index.js';
import { NoWalletProvidedError } from './errors.js';
export function exitWithErrorLog(error) {
    console.error(error instanceof Error ? error.message : error);
    process.exit(1);
}
export async function runCommand(command, action) {
    const options = command.optsWithGlobals();
    try {
        await action(options);
        process.exit(0);
    }
    catch (error) {
        exitWithErrorLog(error);
    }
}
export function applyOptions(command, options) {
    [...options].forEach((option) => {
        command.option(option.alias, option.description, option.default);
    });
    return command;
}
export function tokenFromOptions(options) {
    const token = options.token;
    if (token === undefined) {
        throw new Error('Token type required');
    }
    if (!isTokenType(token)) {
        throw new Error('Invalid token type');
    }
    return token;
}
export function valueFromOptions(options) {
    const value = options.value;
    if (value === undefined) {
        throw new Error('Value is required. Use --value <value>');
    }
    return value;
}
export function getFolderPathFromOptions(options) {
    const folderPath = options.folderPath;
    if (folderPath === undefined) {
        throw new Error('Folder path is required. Use --folderPath <path>');
    }
    // Check if path exists and is a directory
    const stats = statSync(folderPath);
    if (!stats.isDirectory()) {
        throw new Error('Folder path is not a directory');
    }
    return folderPath;
}
export async function addressOrPrivateKeyFromOptions(options) {
    if (options.address !== undefined) {
        return { address: options.address, privateKey: undefined };
    }
    return {
        address: undefined,
        privateKey: await optionalPrivateKeyFromOptions(options),
    };
}
export async function optionalPrivateKeyFromOptions(options) {
    try {
        const key = await privateKeyFromOptions(options);
        return key;
    }
    catch (error) {
        if (error instanceof NoWalletProvidedError) {
            return undefined;
        }
        throw error;
    }
}
export async function privateKeyFromOptions({ mnemonic, privateKey, walletFile, token, }) {
    if (mnemonic !== undefined) {
        if (token === 'kyve') {
            return privateKeyFromKyveMnemonic(mnemonic);
        }
        else {
            // TODO: Implement other token types mnemonic to wallet
            throw new Error('mnemonic provided but this token type mnemonic to wallet is not supported');
        }
    }
    else if (walletFile !== undefined) {
        const wallet = JSON.parse(readFileSync(walletFile, 'utf-8'));
        return token === 'solana' ? bs58.encode(wallet) : wallet;
    }
    else if (privateKey !== undefined) {
        return privateKey;
    }
    // TODO: Get TURBO_WALLET_FILE, TURBO_MNEMONIC, TURBO_PRIVATE_KEY or similar from ENV variables
    // TODO: Add prompts for selecting wallet type and secure input
    throw new NoWalletProvidedError();
}
const tokenToDevGatewayMap = {
    arweave: 'https://arweave.net', // No arweave test net
    solana: 'https://api.devnet.solana.com',
    ethereum: 'https://ethereum-holesky-rpc.publicnode.com',
    kyve: 'https://api.korellia.kyve.network',
    matic: 'https://rpc-amoy.polygon.technology',
    pol: 'https://rpc-amoy.polygon.technology',
};
export function configFromOptions(options) {
    const token = tokenFromOptions(options);
    let paymentUrl = undefined;
    let uploadUrl = undefined;
    let gatewayUrl = undefined;
    if (options.local && options.dev) {
        throw new Error('Cannot use both --local and --dev flags');
    }
    if (options.dev) {
        // Use development endpoints
        paymentUrl = developmentTurboConfiguration.paymentServiceConfig.url;
        uploadUrl = developmentTurboConfiguration.uploadServiceConfig.url;
        gatewayUrl = tokenToDevGatewayMap[token];
    }
    else if (options.local) {
        // Use local endpoints
        paymentUrl = 'http://localhost:4000';
        uploadUrl = 'http://localhost:3000';
        gatewayUrl = 'http://localhost:1984';
    }
    else {
        // Use default endpoints
        paymentUrl = defaultTurboConfiguration.paymentServiceConfig.url;
        uploadUrl = defaultTurboConfiguration.uploadServiceConfig.url;
    }
    // Override gateway, payment, and upload service default endpoints if provided
    if (options.gateway !== undefined) {
        gatewayUrl = options.gateway;
    }
    if (options.paymentUrl !== undefined) {
        paymentUrl = options.paymentUrl;
    }
    if (options.uploadUrl !== undefined) {
        uploadUrl = options.uploadUrl;
    }
    const config = {
        paymentServiceConfig: { url: paymentUrl },
        uploadServiceConfig: { url: uploadUrl },
        gatewayUrl,
        token,
    };
    return config;
}
export async function turboFromOptions(options) {
    const privateKey = await privateKeyFromOptions(options);
    return TurboFactory.authenticated({
        ...configFromOptions(options),
        privateKey,
    });
}
export async function paidByFromOptions({ paidBy: paidByCliInput, ignoreApprovals, useSignerBalanceFirst, }, turbo) {
    const paidBy = await (async () => {
        if (paidByCliInput !== undefined && paidByCliInput.length > 0) {
            return paidByCliInput;
        }
        if (ignoreApprovals) {
            return undefined;
        }
        const { receivedApprovals } = await turbo.getBalance();
        if (receivedApprovals !== undefined && receivedApprovals.length !== 0) {
            // get unique paying addresses from any received approvals
            return Array.from(new Set(receivedApprovals.map((approval) => approval.payingAddress)));
        }
        return undefined;
    })();
    if (paidBy !== undefined && useSignerBalanceFirst) {
        // Add the signer's address to the front of the paidBy array
        paidBy.unshift(await turbo.signer.getNativeAddress());
    }
    return paidBy;
}
export function getUploadFolderOptions(options) {
    if (options.folderPath === undefined) {
        throw new Error('--folder-path is required');
    }
    return {
        folderPath: options.folderPath,
        indexFile: options.indexFile,
        fallbackFile: options.fallbackFile,
        disableManifest: !options.manifest,
        maxConcurrentUploads: +(options.maxConcurrency ?? 1),
    };
}
