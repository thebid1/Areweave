/**
 * Copyright (C) 2022-2024 Permanent Data Solutions, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Secp256k1HdWallet, makeCosmoshubPath } from '@cosmjs/amino';
import { Slip10, Slip10Curve } from '@cosmjs/crypto';
import { toHex } from '@cosmjs/encoding';
import { EthereumSigner } from '@dha-team/arbundles';
import { BigNumber } from 'bignumber.js';
import { createAxiosInstance } from '../../utils/axiosClient.js';
import { sleep } from '../../utils/common.js';
import { TurboWinstonLogger } from '../logger.js';
function hasKyveTxResponse(response) {
    return response.tx_response !== undefined;
}
export const ukyveToTokenAmount = (winston) => winston;
export const KYVEToTokenAmount = (sol) => new BigNumber(sol).times(1e6).valueOf();
export class KyveToken {
    constructor({ logger = TurboWinstonLogger.default, gatewayUrl = 'https://api.kyve.network/', pollingOptions = {
        maxAttempts: 5,
        pollingIntervalMs: 1_000,
        initialBackoffMs: 500,
    }, }) {
        this.logger = logger;
        this.gatewayUrl = gatewayUrl;
        this.pollingOptions = pollingOptions;
    }
    async createAndSubmitTx({ target, tokenAmount, signer, }) {
        const id = await signer.sendTransaction({
            amount: tokenAmount,
            target,
            gatewayUrl: this.gatewayUrl,
        });
        return { id, target };
    }
    async pollForTxBeingAvailable({ txId, }) {
        const { maxAttempts, pollingIntervalMs, initialBackoffMs } = this.pollingOptions;
        this.logger.debug('Polling for transaction...', {
            txId,
            pollingOptions: this.pollingOptions,
        });
        await sleep(initialBackoffMs);
        let attempts = 0;
        while (attempts < maxAttempts) {
            let res = undefined;
            attempts++;
            const axios = createAxiosInstance({
                axiosConfig: { baseURL: this.gatewayUrl },
            });
            try {
                res = await axios.get('cosmos/tx/v1beta1/txs/' + txId);
            }
            catch (err) {
                // Continue retries when request errors
                this.logger.debug('Failed to poll for transaction...', { err });
            }
            const data = res?.data;
            if (data !== undefined && hasKyveTxResponse(data)) {
                if (data.tx_response.code !== 0) {
                    throw new Error(`Transaction failed: ${data.tx_response.code}`);
                }
                return;
            }
            this.logger.debug('Transaction not found, polling...', {
                txId,
                attempts,
                maxAttempts,
                pollingIntervalMs,
            });
            await sleep(pollingIntervalMs);
        }
        throw new Error('Transaction not found after polling, transaction id: ' + txId);
    }
}
export function signerFromKyvePrivateKey(privateKey) {
    // TODO: Use KyveSigner when implemented for on chain native address support
    return new EthereumSigner(privateKey);
}
export async function privateKeyFromKyveMnemonic(mnemonic) {
    const kyveWallet = await Secp256k1HdWallet.fromMnemonic(mnemonic, {
        prefix: 'kyve',
    });
    return toHex(Slip10.derivePath(Slip10Curve.Secp256k1, kyveWallet['seed'], makeCosmoshubPath(0)).privkey);
}
export async function signerFromKyveMnemonic(mnemonic) {
    const privateKey = await privateKeyFromKyveMnemonic(mnemonic);
    return signerFromKyvePrivateKey(privateKey);
}
