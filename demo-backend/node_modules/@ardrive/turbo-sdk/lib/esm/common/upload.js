/**
 * Copyright (C) 2022-2024 Permanent Data Solutions, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Buffer } from 'node:buffer';
import { pLimit } from 'plimit-lit';
import { TurboHTTPService } from './http.js';
import { TurboWinstonLogger } from './logger.js';
export const creditSharingTagNames = {
    shareCredits: 'x-approve-payment',
    sharedWincAmount: 'x-amount',
    approvalExpiresBySeconds: 'x-expires-seconds',
    revokeCredits: 'x-delete-payment-approval',
};
export const developmentUploadServiceURL = 'https://upload.ardrive.dev';
export const defaultUploadServiceURL = 'https://upload.ardrive.io';
export class TurboUnauthenticatedUploadService {
    constructor({ url = defaultUploadServiceURL, retryConfig, logger = TurboWinstonLogger.default, token = 'arweave', }) {
        this.token = token;
        this.logger = logger;
        this.httpService = new TurboHTTPService({
            url: `${url}/v1`,
            retryConfig,
            logger: this.logger,
        });
    }
    async uploadSignedDataItem({ dataItemStreamFactory, dataItemSizeFactory, signal, }) {
        const fileSize = dataItemSizeFactory();
        this.logger.debug('Uploading signed data item...');
        // TODO: add p-limit constraint or replace with separate upload class
        return this.httpService.post({
            endpoint: `/tx/${this.token}`,
            signal,
            data: dataItemStreamFactory(),
            headers: {
                'content-type': 'application/octet-stream',
                'content-length': `${fileSize}`,
            },
        });
    }
}
// NOTE: to avoid redundancy, we use inheritance here - but generally prefer composition over inheritance
export class TurboAuthenticatedBaseUploadService extends TurboUnauthenticatedUploadService {
    constructor({ url = defaultUploadServiceURL, retryConfig, signer, logger, token, }) {
        super({ url, retryConfig, logger, token });
        this.signer = signer;
    }
    async uploadFile({ fileStreamFactory, fileSizeFactory, signal, dataItemOpts, }) {
        const { dataItemStreamFactory, dataItemSizeFactory } = await this.signer.signDataItem({
            fileStreamFactory,
            fileSizeFactory,
            dataItemOpts,
        });
        const signedDataItem = dataItemStreamFactory();
        this.logger.debug('Uploading signed data item...');
        // TODO: add p-limit constraint or replace with separate upload class
        const headers = {
            'content-type': 'application/octet-stream',
            'content-length': `${dataItemSizeFactory()}`,
        };
        if (dataItemOpts !== undefined && dataItemOpts.paidBy !== undefined) {
            const paidBy = Array.isArray(dataItemOpts.paidBy)
                ? dataItemOpts.paidBy
                : [dataItemOpts.paidBy];
            if (dataItemOpts.paidBy.length > 0) {
                headers['x-paid-by'] = paidBy;
            }
        }
        return this.httpService.post({
            endpoint: `/tx/${this.token}`,
            signal,
            data: signedDataItem,
            headers,
        });
    }
    async generateManifest({ paths, indexFile, fallbackFile, }) {
        const indexPath = 
        // Use the user provided index file if it exists,
        indexFile !== undefined && paths[indexFile]?.id !== undefined
            ? indexFile
            : // Else use index.html if it exists,
                paths['index.html']?.id !== undefined
                    ? 'index.html'
                    : // Else use the first file in the paths object.
                        Object.keys(paths)[0];
        const fallbackId = 
        // Use the user provided fallback file if it exists,
        fallbackFile !== undefined && paths[fallbackFile]?.id !== undefined
            ? paths[fallbackFile].id
            : // Else use 404.html if it exists, else use the index path.
                paths['404.html']?.id ?? paths[indexPath].id;
        const manifest = {
            manifest: 'arweave/paths',
            version: '0.2.0',
            index: { path: indexPath },
            paths,
            fallback: { id: fallbackId },
        };
        return manifest;
    }
    getContentType(file, dataItemOpts) {
        const userDefinedContentType = dataItemOpts?.tags?.find((tag) => tag.name === 'Content-Type')?.value;
        if (userDefinedContentType !== undefined) {
            return userDefinedContentType;
        }
        return this.contentTypeFromFile(file);
    }
    async uploadFolder(params) {
        this.logger.debug('Uploading folder...', { params });
        const { dataItemOpts, signal, manifestOptions = {}, maxConcurrentUploads = 1, throwOnFailure = true, } = params;
        const { disableManifest, indexFile, fallbackFile } = manifestOptions;
        const paths = {};
        const response = {
            fileResponses: [],
        };
        const errors = [];
        const uploadFile = async (file) => {
            const contentType = this.getContentType(file, dataItemOpts);
            const dataItemOptsWithContentType = {
                ...dataItemOpts,
                tags: [
                    ...(dataItemOpts?.tags?.filter((tag) => tag.name !== 'Content-Type') ?? []),
                    { name: 'Content-Type', value: contentType },
                ],
            };
            try {
                const result = await this.uploadFile({
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    fileStreamFactory: () => this.getFileStreamForFile(file),
                    fileSizeFactory: () => this.getFileSize(file),
                    signal,
                    dataItemOpts: dataItemOptsWithContentType,
                });
                const relativePath = this.getRelativePath(file, params);
                paths[relativePath] = { id: result.id };
                response.fileResponses.push(result);
            }
            catch (error) {
                if (throwOnFailure) {
                    throw error;
                }
                this.logger.error(`Error uploading file: ${file}`, error);
                errors.push(error);
            }
        };
        const files = await this.getFiles(params);
        const limit = pLimit(maxConcurrentUploads);
        await Promise.all(files.map((file) => limit(() => uploadFile(file))));
        this.logger.debug('Finished uploading files', {
            numFiles: files.length,
            numErrors: errors.length,
            results: response.fileResponses,
        });
        if (errors.length > 0) {
            response.errors = errors;
        }
        if (disableManifest) {
            return response;
        }
        const manifest = await this.generateManifest({
            paths,
            indexFile,
            fallbackFile,
        });
        const tagsWithManifestContentType = [
            ...(dataItemOpts?.tags?.filter((tag) => tag.name !== 'Content-Type') ??
                []),
            { name: 'Content-Type', value: 'application/x.arweave-manifest+json' },
        ];
        const manifestBuffer = Buffer.from(JSON.stringify(manifest));
        const manifestResponse = await this.uploadFile({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            fileStreamFactory: () => this.createManifestStream(manifestBuffer),
            fileSizeFactory: () => manifestBuffer.byteLength,
            signal,
            dataItemOpts: { ...dataItemOpts, tags: tagsWithManifestContentType },
        });
        return {
            ...response,
            manifest,
            manifestResponse,
        };
    }
    async shareCredits({ approvedAddress, approvedWincAmount, expiresBySeconds, }) {
        const dataItemOpts = {
            tags: [
                {
                    name: creditSharingTagNames.shareCredits,
                    value: approvedAddress,
                },
                {
                    name: creditSharingTagNames.sharedWincAmount,
                    value: approvedWincAmount.toString(),
                },
            ],
        };
        if (expiresBySeconds !== undefined) {
            dataItemOpts.tags.push({
                name: creditSharingTagNames.approvalExpiresBySeconds,
                value: expiresBySeconds.toString(),
            });
        }
        const nonceData = Buffer.from(approvedAddress + approvedWincAmount + Date.now());
        const { createdApproval, ...uploadResponse } = await this.uploadFile({
            fileStreamFactory: () => nonceData,
            fileSizeFactory: () => nonceData.byteLength,
            dataItemOpts,
        });
        if (!createdApproval) {
            throw new Error('Failed to create credit share approval but upload has succeeded\n' +
                JSON.stringify(uploadResponse));
        }
        return createdApproval;
    }
    async revokeCredits({ revokedAddress, }) {
        const dataItemOpts = {
            tags: [
                {
                    name: creditSharingTagNames.revokeCredits,
                    value: revokedAddress,
                },
            ],
        };
        const nonceData = Buffer.from(revokedAddress + Date.now());
        const { revokedApprovals, ...uploadResponse } = await this.uploadFile({
            fileStreamFactory: () => nonceData,
            fileSizeFactory: () => nonceData.byteLength,
            dataItemOpts,
        });
        if (!revokedApprovals) {
            throw new Error('Failed to revoke credit share approvals but upload has succeeded\n' +
                JSON.stringify(uploadResponse));
        }
        return revokedApprovals;
    }
}
